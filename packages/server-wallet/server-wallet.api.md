## API Report File for "@statechannels/server-wallet"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Address } from '@statechannels/wallet-core';
import { Allocation } from '@statechannels/client-api-schema';
import { AllocationItem } from '@statechannels/wallet-core';
import { ChannelConstants } from '@statechannels/wallet-core';
import { ChannelId } from '@statechannels/client-api-schema';
import { ChannelResult } from '@statechannels/client-api-schema';
import { CloseChannel } from '@statechannels/wallet-core';
import { CloseChannelParams } from '@statechannels/client-api-schema';
import { Config } from 'knex';
import { CreateChannelParams } from '@statechannels/client-api-schema';
import { DefundChannel } from '@statechannels/wallet-core';
import { Destination } from '@statechannels/wallet-core';
import { ethers } from 'ethers';
import EventEmitter from 'eventemitter3';
import { FundingStatus } from '@statechannels/client-api-schema';
import { FundingStrategy } from '@statechannels/client-api-schema';
import { GetStateParams } from '@statechannels/client-api-schema';
import { JoinChannelParams } from '@statechannels/client-api-schema';
import { JSONSchema } from 'objection';
import Knex from 'knex';
import { Level } from 'pino';
import { Logger } from 'pino';
import { Payload as Message } from '@statechannels/wallet-core';
import { Message as Message_2 } from '@statechannels/client-api-schema';
import { MessageQueuedNotification } from '@statechannels/client-api-schema';
import { Model } from 'objection';
import { ModelOptions } from 'objection';
import { OpenChannel } from '@statechannels/wallet-core';
import { Outcome } from '@statechannels/wallet-core';
import P from 'pino';
import { Participant } from '@statechannels/wallet-core';
import { Participant as Participant_2 } from '@statechannels/client-api-schema';
import { Payload } from '@statechannels/wire-format';
import { Pojo } from 'objection';
import { PrivateKey } from '@statechannels/wallet-core';
import { QueryContext } from 'objection';
import { SignatureEntry } from '@statechannels/wallet-core';
import { SignedState } from '@statechannels/wallet-core';
import { SignedState as SignedState_2 } from '@statechannels/wire-format';
import { SignedStateVarsWithHash } from '@statechannels/wallet-core';
import { SignedStateWithHash } from '@statechannels/wallet-core';
import { SimpleAllocation } from '@statechannels/wallet-core';
import { State } from '@statechannels/wallet-core';
import { StateVariables } from '@statechannels/wallet-core';
import { StateWithHash } from '@statechannels/wallet-core';
import { SubmitChallenge } from '@statechannels/wallet-core';
import { SyncChannelParams } from '@statechannels/client-api-schema';
import { Transaction } from 'objection';
import { TransactionOrKnex } from 'objection';
import { Uint256 } from '@statechannels/wallet-core';
import { UpdateChannelParams } from '@statechannels/client-api-schema';
import { ValidationErrorItem } from 'joi';

// Warning: (ae-forgotten-export) The symbol "ChainServiceArgs" needs to be exported by the entry point index.d.ts
//
// @public
export type ChainServiceConfiguration = {
    attachChainService: boolean;
} & Partial<Exclude<ChainServiceArgs, 'logger'>>;

// @public (undocumented)
export type CreateLedgerChannelParams = Pick<CreateChannelParams, 'participants' | 'allocations' | 'challengeDuration' | 'fundingStrategy'> & {
    fundingStrategy: 'Direct' | 'Fake';
};

// @public
export type DatabaseConfiguration = RequiredDatabaseConfiguration & OptionalDatabaseConfiguration;

// @public
export type DatabaseConnectionConfiguration = RequiredConnectionConfiguration & Partial<OptionalConnectionConfiguration>;

// @public
export type DatabasePoolConfiguration = {
    max?: number;
    min?: number;
};

// @public
export class DBAdmin {
    static createDatabase(config: IncomingWalletConfig): Promise<void>;
    static createDatabaseFromKnex(knex: Knex): Promise<void>;
    static dropDatabase(config: IncomingWalletConfig): Promise<void>;
    static dropDatabaseFromKnex(knex: Knex): Promise<void>;
    static migrateDatabase(config: IncomingWalletConfig): Promise<void>;
    static migrateDatabaseFromKnex(knex: Knex): Promise<void>;
    static truncateDatabase(config: IncomingWalletConfig, tables?: string[]): Promise<void>;
    static truncateDataBaseFromKnex(knex: Knex, tables?: string[]): Promise<void>;
}

// @public (undocumented)
export type DeepPartial<T> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};

// @public (undocumented)
export const DEFAULT_DB_NAME = "server_wallet_test";

// @public (undocumented)
export const DEFAULT_DB_USER = "postgres";

// @public (undocumented)
export const defaultChainServiceConfiguration: ChainServiceConfiguration;

// @public
export const defaultConfig: OptionalWalletConfig;

// @public (undocumented)
export const defaultDatabaseConfiguration: OptionalDatabaseConfiguration & {
    connection: {
        host: string;
        port: number;
        user: string;
    };
};

// @public
export const defaultLoggingConfiguration: LoggingConfiguration;

// @public (undocumented)
export const defaultMetricsConfiguration: {
    timingMetrics: boolean;
};

// @public (undocumented)
export const defaultSyncConfiguration: SyncConfiguration;

// @public (undocumented)
export function defaultTestEngineConfig(partialConfig?: Partial<EngineConfig>): EngineConfig;

// @public (undocumented)
export const defaultTestNetworkConfiguration: NetworkConfiguration;

// Warning: (ae-forgotten-export) The symbol "HasDatabaseConnectionConfigObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function defaultTestWalletConfig(partialConfig?: DeepPartial<WalletConfig & HasDatabaseConnectionConfigObject>): WalletConfig & HasDatabaseConnectionConfigObject;

// @public
export abstract class Engine extends SingleThreadedEngine implements EngineInterface {
    // (undocumented)
    static create(engineConfig: EngineConfig, logger: P.Logger): Promise<SingleThreadedEngine | MultiThreadedEngine>;
}

// @public (undocumented)
export type EngineConfig = {
    skipEvmValidation: boolean;
    metrics: MetricsConfiguration;
    dbConfig: Config;
    chainNetworkID: string;
    workerThreadAmount: number;
};

// @public (undocumented)
export interface EngineInterface {
    // (undocumented)
    challenge(channelId: string): Promise<SingleChannelOutput>;
    // (undocumented)
    closeChannel(args: CloseChannelParams): Promise<SingleChannelOutput>;
    // (undocumented)
    crank(channelIds: string[]): Promise<MultipleChannelOutput>;
    // (undocumented)
    createChannels(args: CreateChannelParams, numberOfChannels: number): Promise<MultipleChannelOutput>;
    // (undocumented)
    getChannels(): Promise<MultipleChannelOutput>;
    // (undocumented)
    getState(args: GetStateParams): Promise<SingleChannelOutput>;
    // (undocumented)
    joinChannels(channelIds: ChannelId[]): Promise<MultipleChannelOutput>;
    // (undocumented)
    pushMessage(m: unknown): Promise<MultipleChannelOutput>;
    // (undocumented)
    pushUpdate(m: unknown): Promise<SingleChannelOutput>;
    // (undocumented)
    syncChannel(args: SyncChannelParams): Promise<SingleChannelOutput>;
    // Warning: (ae-forgotten-export) The symbol "Bytes32" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    syncChannels(chanelIds: Bytes32[]): Promise<MultipleChannelOutput>;
    // (undocumented)
    updateChannel(args: UpdateChannelParams): Promise<SingleChannelOutput>;
}

// @public (undocumented)
export function extractDBConfigFromWalletConfig(walletConfig: WalletConfig): Config;

// Warning: (ae-forgotten-export) The symbol "DatabaseConnectionConfigObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function getDatabaseConnectionConfig(config: WalletConfig): DatabaseConnectionConfigObject & {
    host: string;
    port: number;
};

// @public (undocumented)
export function hasNewObjective(response: SingleChannelOutput): response is SingleChannelOutput & {
    newObjective: WalletObjective;
};

// @public
export type IncomingWalletConfig = RequiredWalletConfig & Partial<OptionalWalletConfig>;

// @public
export type InternalError = {
    type: 'InternalError';
    error: Error;
};

// @public (undocumented)
export function isMultipleChannelOutput(output: SingleChannelOutput | MultipleChannelOutput): output is MultipleChannelOutput;

// @public
export type LoggingConfiguration = {
    logLevel: Level;
    logDestination: string;
};

export { Message }

// @public
export type MetricsConfiguration = {
    timingMetrics: boolean;
    metricsOutputFile?: string;
};

// @public (undocumented)
export type MultipleChannelOutput = {
    outbox: Outgoing[];
    channelResults: ChannelResult[];
    newObjectives: WalletObjective[];
    completedObjectives: WalletObjective[];
    chainRequests: ChainRequest[];
};

// @public
export class MultiThreadedEngine extends SingleThreadedEngine {
    protected constructor(engineConfig: EngineConfig, logger: P.Logger);
    // (undocumented)
    static create(engineConfig: EngineConfig, logger: P.Logger): Promise<MultiThreadedEngine>;
    // (undocumented)
    destroy(): Promise<void>;
    // (undocumented)
    pushMessage(rawPayload: unknown): Promise<MultipleChannelOutput>;
    // (undocumented)
    pushUpdate(rawPayload: unknown): Promise<SingleChannelOutput>;
    // (undocumented)
    updateChannel(args: UpdateChannelParams): Promise<SingleChannelOutput>;
    // (undocumented)
    warmUpThreads(): Promise<void>;
    }

// @public
export type NetworkConfiguration = {
    chainNetworkID: number;
};

// @public (undocumented)
export type ObjectiveDoneResult = ObjectiveSuccess | ObjectiveError;

// @public (undocumented)
export type ObjectiveError = ObjectiveTimedOutError | InternalError;

// @public
export type ObjectiveResult = {
    done: Promise<ObjectiveDoneResult>;
    currentStatus: ObjectiveStatus;
    objectiveId: string;
    channelId: string;
};

// @public
export type ObjectiveSuccess = {
    channelId: string;
    type: 'Success';
};

// @public
export type ObjectiveTimedOutError = {
    lastProgressMadeAt: Date;
    objectiveId: string;
    type: 'ObjectiveTimedOutError';
};

// @public
export type OptionalConnectionConfiguration = {
    port: number;
} | string;

// @public (undocumented)
export type OptionalDatabaseConfiguration = {
    pool?: DatabasePoolConfiguration;
    debug?: boolean;
    connection: OptionalConnectionConfiguration;
};

// @public
export interface OptionalWalletConfig {
    // (undocumented)
    chainServiceConfiguration: ChainServiceConfiguration;
    // (undocumented)
    databaseConfiguration: OptionalDatabaseConfiguration;
    // (undocumented)
    loggingConfiguration: LoggingConfiguration;
    // (undocumented)
    metricsConfiguration: MetricsConfiguration;
    privateKey?: string;
    // (undocumented)
    skipEvmValidation: boolean;
    // (undocumented)
    syncConfiguration: SyncConfiguration;
    // (undocumented)
    workerThreadAmount: number;
}

// Warning: (ae-forgotten-export) The symbol "Notice" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Outgoing = Notice;

// @public (undocumented)
export type Output = SingleChannelOutput | MultipleChannelOutput;

// Warning: (ae-forgotten-export) The symbol "PartialConfigObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function overwriteConfigWithDatabaseConnection(config: WalletConfig, databaseConnectionConfig: PartialConfigObject | string): WalletConfig;

// @public
export type RequiredConnectionConfiguration = {
    database: string;
    host: string;
    user: string;
    password?: string;
} | string;

// @public
export type RequiredDatabaseConfiguration = {
    connection: RequiredConnectionConfiguration;
};

// @public
export type RequiredWalletConfig = {
    databaseConfiguration: RequiredDatabaseConfiguration;
    networkConfiguration: NetworkConfiguration;
};

// @public (undocumented)
export type SingleChannelOutput = {
    outbox: Outgoing[];
    channelResult: ChannelResult;
    newObjective: WalletObjective | undefined;
    chainRequests: ChainRequest[];
};

// @public
export class SingleThreadedEngine implements EngineInterface {
    protected constructor(config: EngineConfig, logger: Logger);
    addSigningKey(privateKey: PrivateKey): Promise<void>;
    // (undocumented)
    approveObjectives(objectiveIds: string[]): Promise<{
        objectives: WalletObjective[];
        messages: Message_2[];
        chainRequests: ChainRequest[];
        channelResults: ChannelResult[];
    }>;
    // (undocumented)
    chainNetworkId: string;
    challenge(channelId: string): Promise<SingleChannelOutput>;
    closeChannel({ channelId, }: CloseChannelParams): Promise<SingleChannelOutput & {
        newObjective: WalletObjective;
    }>;
    closeChannels(channelIds: Bytes32[]): Promise<MultipleChannelOutput>;
    crank(channelIds: string[]): Promise<MultipleChannelOutput>;
    // (undocumented)
    static create(engineConfig: EngineConfig, logger: Logger): Promise<SingleThreadedEngine>;
    createChannel(args: CreateChannelParams): Promise<SingleChannelOutput & {
        newObjective: WalletObjective;
    }>;
    createChannels(args: CreateChannelParams, numberOfChannels: number): Promise<MultipleChannelOutput>;
    createLedgerChannel(args: Pick<CreateChannelParams, 'participants' | 'allocations' | 'challengeDuration'>, fundingStrategy?: 'Direct' | 'Fake'): Promise<SingleChannelOutput & {
        newObjective: WalletObjective;
    }>;
    destroy(): Promise<void>;
    getApprovedObjectives(): Promise<WalletObjective[]>;
    getChannels(): Promise<MultipleChannelOutput>;
    getLedgerChannels(participants: Participant_2[]): Promise<MultipleChannelOutput>;
    getObjective(objectiveId: string): Promise<WalletObjective>;
    getSigningAddress(): Promise<Address>;
    getState({ channelId }: GetStateParams): Promise<SingleChannelOutput>;
    joinChannel({ channelId }: JoinChannelParams): Promise<SingleChannelOutput>;
    joinChannels(channelIds: ChannelId[]): Promise<MultipleChannelOutput>;
    // (undocumented)
    knex: Knex;
    // Warning: (ae-forgotten-export) The symbol "LedgerManager" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    ledgerManager: LedgerManager;
    // (undocumented)
    protected logger: Logger;
    // Warning: (ae-forgotten-export) The symbol "ObjectiveManager" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    objectiveManager: ObjectiveManager;
    pushMessage(rawPayload: unknown): Promise<MultipleChannelOutput>;
    pushUpdate(rawPayload: unknown): Promise<SingleChannelOutput>;
    registerAppBytecode(appDefinition: string, bytecode: string): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "Store" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    store: Store;
    syncChannel({ channelId }: SyncChannelParams): Promise<SingleChannelOutput>;
    syncChannels(channelIds: Bytes32[]): Promise<MultipleChannelOutput>;
    syncObjectives(objectiveIds: string[]): Promise<Message_2[]>;
    updateChannel({ channelId, allocations, appData, }: UpdateChannelParams): Promise<SingleChannelOutput>;
}

// @public (undocumented)
export type SyncConfiguration = {
    pollInterval: number;
    timeOutThreshold: number;
    staleThreshold: number;
};

// @public
export type UpdateChannelError = {
    type: 'InternalError';
    channelId: string;
    error: Error;
};

// @public (undocumented)
export type UpdateChannelResult = UpdateChannelSuccess | UpdateChannelError;

// @public
export type UpdateChannelSuccess = {
    type: 'Success';
    channelId: string;
    result: ChannelResult;
};

// @public (undocumented)
export function validateEngineConfig(config: Record<string, any>): {
    valid: boolean;
    value: WalletConfig | undefined;
    errors: ValidationErrorItem[];
};

// @public (undocumented)
export class Wallet extends EventEmitter<WalletEvents> {
    approveObjectives(objectiveIds: string[]): Promise<ObjectiveResult[]>;
    closeChannels(channelIds: string[]): Promise<ObjectiveResult[]>;
    // Warning: (ae-forgotten-export) The symbol "MessageServiceFactory" needs to be exported by the entry point index.d.ts
    static create(incomingConfig: IncomingWalletConfig, messageServiceFactory: MessageServiceFactory): Promise<Wallet>;
    createChannels(channelParameters: CreateChannelParams[]): Promise<ObjectiveResult[]>;
    createLedgerChannel(channelParams: CreateLedgerChannelParams): Promise<ObjectiveResult>;
    // (undocumented)
    destroy(): Promise<void>;
    // (undocumented)
    getChannels(): Promise<ChannelResult[]>;
    // (undocumented)
    getSigningAddress(): Promise<Address>;
    jumpStartObjectives(): Promise<ObjectiveResult[]>;
    // Warning: (ae-forgotten-export) The symbol "MessageServiceInterface" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    get messageService(): MessageServiceInterface;
    registerAppDefinition(appDefinition: string): Promise<void>;
    registerPeerMessageService(peerUrl: string): Promise<void>;
    updateChannel(channelId: string, allocations: Allocation[], appData: string): Promise<UpdateChannelResult>;
}

// @public
export type WalletConfig = RequiredWalletConfig & OptionalWalletConfig;

// @public (undocumented)
export interface WalletEvents {
    // (undocumented)
    ChannelUpdated: (c: ChannelResult) => void;
    // (undocumented)
    ObjectiveCompleted: (o: WalletObjective) => void;
    // (undocumented)
    ObjectiveProposed: (o: WalletObjective) => void;
    // (undocumented)
    ObjectiveTimedOut: (o: WalletObjective) => void;
}


// Warnings were encountered during analysis:
//
// src/engine/types.ts:31:3 - (ae-forgotten-export) The symbol "ChainRequest" needs to be exported by the entry point index.d.ts
// src/engine/types.ts:69:39 - (ae-forgotten-export) The symbol "WalletObjective" needs to be exported by the entry point index.d.ts
// src/wallet/types.ts:49:3 - (ae-forgotten-export) The symbol "ObjectiveStatus" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
