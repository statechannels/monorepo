{
  "language": "Solidity",
  "sources": {
    "contracts/AssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport './Outcome.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport './interfaces/IAssetHolder.sol';\n\n/**\n * @dev An implementation of the IAssetHolder interface. The AssetHolder contract escrows ETH or tokens against state channels. It allows assets to be internally accounted for, and ultimately prepared for transfer from one channel to other channel and/or external destinations, as well as for guarantees to be claimed. Note there is no deposit function and the _transferAsset function is unimplemented; inheriting contracts should implement these functions in a manner appropriate to the asset type (e.g. ETH or ERC20 tokens).\n */\ncontract AssetHolder is IAssetHolder {\n    using SafeMath for uint256;\n\n    address public AdjudicatorAddress;\n\n    mapping(bytes32 => uint256) public holdings;\n\n    mapping(bytes32 => bytes32) public assetOutcomeHashes;\n\n    /**\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries. Performs no checks.\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries. Performs no checks.\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     * @param destination External destination or channel to transfer funds *to*.\n     */\n    function _transfer(bytes32 fromChannelId, bytes memory allocationBytes, bytes32 destination) internal {\n        Outcome.AllocationItem[] memory allocation = abi.decode(\n            allocationBytes,\n            (Outcome.AllocationItem[])\n        );\n        uint256 balance = holdings[fromChannelId];\n        uint256 affordsForDestination;\n        uint256 residualAllocationAmount;\n        uint256 _amount;\n        uint256 i;\n        bool deleteHash = false;\n\n        // loop over allocations and decrease balance until we hit the specified destination\n        for (i = 0; i < allocation.length; i++) {\n            if (balance == 0) {\n                revert('_transfer | fromChannel affords 0 for destination');\n            }\n            _amount = allocation[i].amount;\n            if (allocation[i].destination == destination) {\n                 if (balance < _amount) {\n                    affordsForDestination = balance;\n                    residualAllocationAmount = _amount - balance;\n                    balance = 0;\n                } else {\n                    affordsForDestination = _amount;\n                    residualAllocationAmount = 0;\n                    balance = balance.sub(_amount);\n                }\n            break; // means that i holds the index of the destination that may need to be altered or removed\n            }\n            if (balance < _amount) {\n                balance = 0;\n            } else {\n                balance = balance.sub(_amount);\n            }\n        }\n\n        // effects\n        holdings[fromChannelId] -= affordsForDestination;\n\n        // construct new outcome\n\n        bytes memory encodedAllocation; \n\n        if (residualAllocationAmount > 0) {\n            // new allocation identical save for a single entry \n            Outcome.AllocationItem[] memory newAllocation = new Outcome.AllocationItem[](\n                allocation.length\n            );\n            for (uint256 k = 0; k < allocation.length; k++) {\n                newAllocation[k] = allocation[k];\n                if (allocation[k].destination == destination) {\n                    newAllocation[k].amount = residualAllocationAmount;\n                }\n            }\n            encodedAllocation = abi.encode(newAllocation);\n        }\n\n        if (residualAllocationAmount == 0) {\n            Outcome.AllocationItem[] memory splicedAllocation = new Outcome.AllocationItem[](\n                allocation.length - 1\n            );\n            // full payout so we want to splice a shorter outcome\n            for (uint256 k = 0; k < i; k++) {\n                splicedAllocation[k] = allocation[k];\n            }\n            for (uint256 k = i + 1; k < allocation.length; k++) {\n                splicedAllocation[k - 1] = allocation[k];\n            }\n            if (splicedAllocation.length == 0) {\n                deleteHash = true;\n            }\n            encodedAllocation = abi.encode(splicedAllocation);\n        }\n\n        // replace or delete hash\n        if (deleteHash) {\n            delete assetOutcomeHashes[fromChannelId];\n        } else {\n            assetOutcomeHashes[fromChannelId] = keccak256(\n                abi.encode(\n                    Outcome.AssetOutcome(\n                        uint8(Outcome.AssetOutcomeType.Allocation),\n                        encodedAllocation\n                    )\n                )\n            );\n        } \n\n        // storage updated BEFORE asset transferred (prevent reentrancy)\n\n        if (_isExternalDestination(destination)) {\n            _transferAsset(_bytes32ToAddress(destination), affordsForDestination);\n            emit AssetTransferred(fromChannelId, destination, affordsForDestination);\n        } else {\n            holdings[destination] += affordsForDestination;\n        }\n        \n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. No checks performed.\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. No checks performed.\n     * @param channelId Unique identifier for a state channel.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     */\n    function _transferAll(bytes32 channelId, bytes memory allocationBytes) internal {\n        Outcome.AllocationItem[] memory allocation = abi.decode(\n            allocationBytes,\n            (Outcome.AllocationItem[])\n        );\n        uint256 balance = holdings[channelId];\n        uint256 numPayouts = 0;\n        uint256 numNewAllocationItems = allocation.length;\n        uint256 _amount;\n        bool overlap;\n        uint256 finalPayoutAmount;\n        uint256 firstNewAllocationItemAmount;\n\n        for (uint256 i = 0; i < allocation.length; i++) {\n            if (balance == 0) {\n                // if funds are completely depleted, keep the allocationItem and do not pay out\n            } else {\n                _amount = allocation[i].amount;\n                if (balance < _amount) {\n                    // if funds still exist but are insufficient for this allocationItem, payout what's available and keep the allocationItem (but reduce the amount allocated)\n                    // this block is never executed more than once\n                    numPayouts++;\n                    overlap = true;\n                    finalPayoutAmount = balance;\n                    firstNewAllocationItemAmount = _amount.sub(balance);\n                    balance = 0;\n                } else {\n                    // if ample funds still exist, pay them out and discard the allocationItem\n                    numPayouts++;\n                    numNewAllocationItems = numNewAllocationItems.sub(1);\n                    balance = balance.sub(_amount);\n                }\n            }\n        }\n\n        // effects\n        holdings[channelId] = balance;\n\n        if (numNewAllocationItems > 0) {\n            // construct newAllocation\n            Outcome.AllocationItem[] memory newAllocation = new Outcome.AllocationItem[](\n                numNewAllocationItems\n            );\n            for (uint256 k = 0; k < numNewAllocationItems; k++) {\n                newAllocation[k] = allocation[allocation.length.sub(numNewAllocationItems).add(k)];\n                if (overlap && k == 0) {\n                    newAllocation[k].amount = firstNewAllocationItemAmount;\n                }\n            }\n\n            // store hash\n            assetOutcomeHashes[channelId] = keccak256(\n                abi.encode(\n                    Outcome.AssetOutcome(\n                        uint8(Outcome.AssetOutcomeType.Allocation),\n                        abi.encode(newAllocation)\n                    )\n                )\n            );\n        } else {\n            delete assetOutcomeHashes[channelId];\n        }\n        // holdings updated BEFORE asset transferred (prevent reentrancy)\n        uint256 payoutAmount;\n        for (uint256 m = 0; m < numPayouts; m++) {\n            if (overlap && m == numPayouts.sub(1)) {\n                payoutAmount = finalPayoutAmount;\n            } else {\n                payoutAmount = allocation[m].amount;\n            }\n            if (_isExternalDestination(allocation[m].destination)) {\n                _transferAsset(_bytes32ToAddress(allocation[m].destination), payoutAmount);\n                emit AssetTransferred(channelId, allocation[m].destination, payoutAmount);\n            } else {\n                holdings[allocation[m].destination] += payoutAmount;\n            }\n        }\n    }\n\n\n\n    // **************\n    // Public methods\n    // **************\n\n    /**\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     * @param destination External destination or channel to transfer funds *to*.\n     */\n    function transfer(bytes32 fromChannelId, bytes memory allocationBytes, bytes32 destination) public {\n        // checks\n        require(\n            assetOutcomeHashes[fromChannelId] ==\n                keccak256(\n                    abi.encode(\n                        Outcome.AssetOutcome(\n                            uint8(Outcome.AssetOutcomeType.Allocation),\n                            allocationBytes\n                        )\n                    )\n                ),\n            'transfer | submitted data does not match stored assetOutcomeHash'\n        );\n        _transfer(fromChannelId, allocationBytes, destination);\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. Checks against the storage in this contract.\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. Checks against the storage in this contract.\n     * @param channelId Unique identifier for a state channel.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     */\n    function transferAll(bytes32 channelId, bytes memory allocationBytes) public override {\n        // checks\n        require(\n            assetOutcomeHashes[channelId] ==\n                keccak256(\n                    abi.encode(\n                        Outcome.AssetOutcome(\n                            uint8(Outcome.AssetOutcomeType.Allocation),\n                            allocationBytes\n                        )\n                    )\n                ),\n            'transferAll | submitted data does not match stored assetOutcomeHash'\n        );\n        _transferAll(channelId, allocationBytes);\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\n     * @param channelId Unique identifier for a state channel.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     */\n    function transferAllAdjudicatorOnly(bytes32 channelId, bytes calldata allocationBytes)\n        external\n        virtual\n        AdjudicatorOnly\n    {\n        _transferAll(channelId, allocationBytes);\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     */\n    function claimAll(\n        bytes32 guarantorChannelId,\n        bytes memory guaranteeBytes,\n        bytes memory allocationBytes\n    ) public override {\n        \n        // CHECKS\n        require(\n            assetOutcomeHashes[guarantorChannelId] ==\n                keccak256(\n                    abi.encode(\n                        Outcome.AssetOutcome(\n                            uint8(Outcome.AssetOutcomeType.Guarantee),\n                            guaranteeBytes\n                        )\n                    )\n                ),\n            'claimAll | submitted data does not match assetOutcomeHash stored against guarantorChannelId'\n        );\n\n        Outcome.Guarantee memory guarantee = abi.decode(guaranteeBytes, (Outcome.Guarantee));\n\n        require(\n            assetOutcomeHashes[guarantee.targetChannelId] ==\n                keccak256(\n                    abi.encode(\n                        Outcome.AssetOutcome(\n                            uint8(Outcome.AssetOutcomeType.Allocation),\n                            allocationBytes\n                        )\n                    )\n                ),\n            'claimAll | submitted data does not match assetOutcomeHash stored against targetChannelId'\n        );\n\n        uint256 balance = holdings[guarantorChannelId];\n\n        Outcome.AllocationItem[] memory allocation = abi.decode(\n            allocationBytes,\n            (Outcome.AllocationItem[])\n        ); // this remains constant length\n\n        uint256[] memory payouts = new uint256[](allocation.length);\n        uint256 newAllocationLength = allocation.length;\n\n        // first increase payouts according to guarantee\n        for (uint256 i = 0; i < guarantee.destinations.length; i++) {\n            // for each destination in the guarantee\n            bytes32 _destination = guarantee.destinations[i];\n            for (uint256 j = 0; j < allocation.length; j++) {\n                if (balance == 0) {\n                    break;\n                }\n                if (_destination == allocation[j].destination) {\n                    // find amount allocated to that destination (if it exists in channel alllocation)\n                    uint256 _amount = allocation[j].amount;\n                    if (_amount > 0) {\n                        if (balance >= _amount) {\n                            balance = balance.sub(_amount);\n                            allocation[j].amount = 0; // subtract _amount;\n                            newAllocationLength = newAllocationLength.sub(1);\n                            payouts[j] += _amount;\n                            break;\n                        } else {\n                            allocation[j].amount = _amount.sub(balance);\n                            payouts[j] += balance;\n                            balance = 0;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // next, increase payouts according to original allocation order\n        // this block only has an effect if balance > 0\n        for (uint256 j = 0; j < allocation.length; j++) {\n            // for each entry in the target channel's outcome\n            if (balance == 0) {\n                break;\n            }\n            uint256 _amount = allocation[j].amount;\n            if (_amount > 0) {\n                if (balance >= _amount) {\n                    balance = balance.sub(_amount);\n                    allocation[j].amount = 0; // subtract _amount;\n                    newAllocationLength = newAllocationLength.sub(1);\n                    payouts[j]+= _amount;\n                } else {\n                    allocation[j].amount = _amount.sub(balance);\n                    payouts[j]+= balance;\n                    balance = 0;\n                }\n            }\n        }\n\n        // EFFECTS\n        holdings[guarantorChannelId] = balance;\n       \n\n        // at this point have payouts array of uint256s, each corresponding to original destinations\n        // and allocations has some zero amounts which we want to prune\n        Outcome.AllocationItem[] memory newAllocation;\n        if (newAllocationLength > 0) {\n            newAllocation = new Outcome.AllocationItem[](newAllocationLength);\n        }\n\n        uint256 k = 0;\n        for (uint256 j = 0; j < allocation.length; j++) {\n            // for each destination in the target channel's allocation\n            if (allocation[j].amount > 0) {\n                newAllocation[k] = allocation[j];\n                k++;\n            }\n        }\n        assert(k == newAllocationLength);\n\n        if (newAllocationLength > 0) {\n            // store hash\n            assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\n                abi.encode(\n                    Outcome.AssetOutcome(\n                        uint8(Outcome.AssetOutcomeType.Allocation),\n                        abi.encode(newAllocation)\n                    )\n                )\n            );\n        } else {\n            delete assetOutcomeHashes[guarantorChannelId];\n            delete assetOutcomeHashes[guarantee.targetChannelId];\n        }\n\n        // INTERACTIONS\n        for (uint256 j = 0; j < allocation.length; j++) {\n            // for each destination in the target channel's allocation\n            if (payouts[j] > 0) {\n                if (_isExternalDestination(allocation[j].destination)) {\n                    _transferAsset(_bytes32ToAddress(allocation[j].destination), payouts[j]);\n                    emit AssetTransferred(\n                        guarantorChannelId,\n                        allocation[j].destination,\n                        payouts[j]\n                    );\n                } else {\n                    holdings[allocation[j].destination] += payouts[j];\n                }\n            }\n        }\n    }\n\n    // **************\n    // Permissioned methods\n    // **************\n\n    modifier AdjudicatorOnly {\n        require(msg.sender == AdjudicatorAddress, 'Only the NitroAdjudicator is authorized');\n        _;\n    }\n\n    /**\n     * @notice Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping\n     * @param channelId Unique identifier for a state channel.\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\n     */\n    function _setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash) internal {\n        require(assetOutcomeHashes[channelId] == bytes32(0), 'Outcome hash already exists');\n        assetOutcomeHashes[channelId] = assetOutcomeHash;\n    }\n\n    /**\n     * @notice Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\n     * @param channelId Unique identifier for a state channel.\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\n     */\n    function setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash)\n        external\n        AdjudicatorOnly\n        returns (bool success)\n    {\n        _setAssetOutcomeHash(channelId, assetOutcomeHash);\n        return true;\n    }\n\n    // **************\n    // Internal methods\n    // **************\n\n    /**\n     * @notice Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\n     * @dev Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\n     * @param destination ethereum address to be credited.\n     * @param amount Quantity of assets to be transferred.\n     */\n    function _transferAsset(address payable destination, uint256 amount) internal virtual {}\n\n    /**\n     * @notice Checks if a given destination is external (and can therefore have assets transferred to it) or not.\n     * @dev Checks if a given destination is external (and can therefore have assets transferred to it) or not.\n     * @param destination Destination to be checked.\n     * @return True if the destination is external, false otherwise.\n     */\n    function _isExternalDestination(bytes32 destination) internal pure returns (bool) {\n        return uint96(bytes12(destination)) == 0;\n    }\n\n    /**\n     * @notice Converts an ethereum address to a nitro external destination.\n     * @dev Converts an ethereum address to a nitro external destination.\n     * @param participant The address to be converted.\n     * @return The input address left-padded with zeros.\n     */\n    function _addressToBytes32(address participant) internal pure returns (bytes32) {\n        return bytes32(uint256(participant));\n    }\n\n    /**\n     * @notice Converts a nitro destination to an ethereum address.\n     * @dev Converts a nitro destination to an ethereum address.\n     * @param destination The destination to be converted.\n     * @return The rightmost 160 bits of the input string.\n     */\n    function _bytes32ToAddress(bytes32 destination) internal pure returns (address payable) {\n        return address(uint160(uint256(destination)));\n    }\n}\n"
    },
    "contracts/Outcome.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nlibrary Outcome {\n    //An outcome is an array of OutcomeItems\n    // Outcome = OutcomeItem[]\n    // OutcomeItem = (AssetHolderAddress, AssetOutcome)\n    // AssetOutcome = (AssetOutcomeType, Allocation | Guarantee)\n    // Allocation = AllocationItem[]\n    // AllocationItem = (Destination, Amount)\n    // Guarantee = (ChannelAddress, Destination[])\n    // Destination = ChannelAddress | ExternalDestination\n\n    struct OutcomeItem {\n        address assetHolderAddress;\n        bytes assetOutcomeBytes; // abi.encode(AssetOutcome)\n    }\n\n    enum AssetOutcomeType {Allocation, Guarantee}\n\n    struct AssetOutcome {\n        uint8 assetOutcomeType; // AssetOutcomeType.Allocation or AssetOutcomeType.Guarantee\n        bytes allocationOrGuaranteeBytes; // abi.encode(AllocationItem[]) or abi.encode(Guarantee), depending on OutcomeType\n    }\n\n    // reserve Allocation to refer to AllocationItem[]\n    struct AllocationItem {\n        bytes32 destination;\n        uint256 amount;\n    }\n\n    struct Guarantee {\n        bytes32 targetChannelId;\n        bytes32[] destinations;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/IAssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev The IAssetHolder interface calls for functions that allow assets to be transferred from one channel to other channel and/or external destinations, as well as for guarantees to be claimed.\n */\ninterface IAssetHolder {\n    /**\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel.\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel.\n     * @param channelId Unique identifier for a state channel.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     */\n    function transferAll(bytes32 channelId, bytes calldata allocationBytes) external;\n\n    /**\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     */\n    function claimAll(\n        bytes32 guarantorChannelId,\n        bytes calldata guaranteeBytes,\n        bytes calldata allocationBytes\n    ) external;\n\n    /**\n     * @dev Indicates that `amountDeposited` has been deposited into `destination`.\n     * @param destination The channel being deposited into.\n     * @param amountDeposited The amount being deposited.\n     * @param destinationHoldings The new holdings for `destination`.\n     */\n    event Deposited(\n        bytes32 indexed destination,\n        uint256 amountDeposited,\n        uint256 destinationHoldings\n    );\n\n    /**\n     * @dev Indicates that `amount` assets have been transferred to the external destination denoted by `destination`.\n     * @param channelId The channelId of the funds being withdrawn.\n     * @param destination An external destination, left-padded with zeros.\n     * @param amount Number of assets transferred (wei or tokens).\n     */\n    event AssetTransferred(bytes32 indexed channelId, bytes32 indexed destination, uint256 amount);\n}\n"
    },
    "contracts/test/TESTAssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport '../AssetHolder.sol';\n\n/**\n * @dev This contract extends the AssetHolder contract to enable it to be more easily unit-tested. It exposes public or external functions that set storage variables or wrap otherwise internal functions. It should not be deployed in a production environment.\n */\ncontract TESTAssetHolder is AssetHolder {\n    /**\n     * @notice Constructor function storing the AdjudicatorAddress.\n     * @dev Constructor function storing the AdjudicatorAddress.\n     * @param _AdjudicatorAddress Address of an Adjudicator  contract, supplied at deploy-time.\n     */\n    constructor(address _AdjudicatorAddress) public {\n        AdjudicatorAddress = _AdjudicatorAddress;\n    }\n\n    // Public wrappers for internal methods:\n\n    /**\n     * @dev Manually set the holdings mapping to a given amount for a given channelId.  Shortcuts the deposit workflow (ONLY USE IN A TESTING ENVIRONMENT)\n     * @param channelId Unique identifier for a state channel.\n     * @param amount The number of assets that should now be \"escrowed: against channelId\n     */\n    function setHoldings(bytes32 channelId, uint256 amount) external {\n        holdings[channelId] = amount;\n    }\n\n    /**\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping, but circumvents the AdjudicatorOnly modifier (thereby allowing externally owned accounts to call the method).\n     * @param channelId Unique identifier for a state channel.\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\n     */\n    function setAssetOutcomeHashPermissionless(bytes32 channelId, bytes32 assetOutcomeHash)\n        external\n        returns (bool success)\n    {\n        _setAssetOutcomeHash(channelId, assetOutcomeHash);\n        return true;\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. No checks performed against storage in this contract. Permissions have been bypassed for testing purposes.\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. No checks performed against storage in this contract. Permissions have been bypassed for testing purposes.\n     * @param channelId Unique identifier for a state channel.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     */\n    function transferAllAdjudicatorOnly(bytes32 channelId, bytes calldata allocationBytes)\n        external\n        override\n    {\n        _transferAll(channelId, allocationBytes);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Checks if a given destination is external (and can therefore have assets transferred to it) or not.\n     * @param destination Destination to be checked.\n     * @return True if the destination is external, false otherwise.\n     */\n    function isExternalDestination(bytes32 destination) public pure returns (bool) {\n        return _isExternalDestination(destination);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Converts an ethereum address to a nitro external destination.\n     * @param participant The address to be converted.\n     * @return The input address left-padded with zeros.\n     */\n    function addressToBytes32(address participant) public pure returns (bytes32) {\n        return _addressToBytes32(participant);\n    }\n}\n"
    },
    "contracts/test/TestErc20AssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport '../ERC20AssetHolder.sol';\nimport './TESTAssetHolder.sol';\n\n/**\n * @dev This contract is a clone of the ERC20AssetHolder contract. It will be initialized to point to the TestNitroAdjudicator.\n */\ncontract TestErc20AssetHolder is ERC20AssetHolder {\n    constructor(address _AdjudicatorAddress, address _TokenAddress)\n        public\n        ERC20AssetHolder(_AdjudicatorAddress, _TokenAddress)\n    {}\n\n    /**\n     * @dev Manually set the holdings mapping to a given amount for a given channelId.  Shortcuts the deposit workflow (ONLY USE IN A TESTING ENVIRONMENT)\n     * @param channelId Unique identifier for a state channel.\n     * @param amount The number of assets that should now be \"escrowed: against channelId\n     */\n    function setHoldings(bytes32 channelId, uint256 amount) external {\n        holdings[channelId] = amount;\n    }\n\n    /**\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping, but circumvents the AdjudicatorOnly modifier (thereby allowing externally owned accounts to call the method).\n     * @param channelId Unique identifier for a state channel.\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\n     */\n    function setAssetOutcomeHashPermissionless(bytes32 channelId, bytes32 assetOutcomeHash)\n        external\n        returns (bool success)\n    {\n        _setAssetOutcomeHash(channelId, assetOutcomeHash);\n        return true;\n    }\n}\n"
    },
    "contracts/ERC20AssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport './AssetHolder.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/**\n * @dev Ther ERC20AssetHolder contract extends the AssetHolder contract, and adds the following functionality: it allows ERC20 tokens to be escrowed against a state channelId and to be transferred to external destinations.\n */\ncontract ERC20AssetHolder is AssetHolder {\n    using SafeMath for uint256;\n\n    IERC20 public Token;\n\n    /**\n     * @notice Constructor function storing the AdjudicatorAddress and instantiating an interface to an ERC20 Token contract.\n     * @dev Constructor function storing the AdjudicatorAddress and instantiating an interface to an ERC20 Token contract.\n     * @param _AdjudicatorAddress Address of an Adjudicator  contract, supplied at deploy-time.\n     * @param _TokenAddress Address of an ERC20 Token  contract, supplied at deploy-time.\n     */\n    constructor(address _AdjudicatorAddress, address _TokenAddress) public {\n        AdjudicatorAddress = _AdjudicatorAddress;\n        Token = IERC20(_TokenAddress);\n    }\n\n    /**\n     * @notice Deposit ERC20 tokens against a given destination.\n     * @dev Deposit ERC20 tokens against a given destination.\n     * @param destination ChannelId to be credited.\n     * @param expectedHeld The amount of tokens that the depositor believes are _already_ escrowed against the channelId.\n     * @param amount The intended number of tokens to be deposited.\n     */\n    function deposit(\n        bytes32 destination,\n        uint256 expectedHeld,\n        uint256 amount\n    ) public {\n        require(!_isExternalDestination(destination), 'Cannot deposit to external destination');\n        uint256 amountDeposited;\n        // this allows participants to reduce the wait between deposits, while protecting them from losing funds by depositing too early. Specifically it protects against the scenario:\n        // 1. Participant A deposits\n        // 2. Participant B sees A's deposit, which means it is now safe for them to deposit\n        // 3. Participant B submits their deposit\n        // 4. The chain re-orgs, leaving B's deposit in the chain but not A's\n        require(\n            holdings[destination] >= expectedHeld,\n            'Deposit | holdings[destination] is less than expected'\n        );\n        require(\n            holdings[destination] < expectedHeld.add(amount),\n            'Deposit | holdings[destination] already meets or exceeds expectedHeld + amount'\n        );\n\n        // The depositor wishes to increase the holdings against channelId to amount + expectedHeld\n        // The depositor need only deposit (at most) amount + (expectedHeld - holdings) (the term in parentheses is non-positive)\n\n        amountDeposited = expectedHeld.add(amount).sub(holdings[destination]); // strictly positive\n        // require successful deposit before updating holdings (protect against reentrancy)\n        require(\n            Token.transferFrom(msg.sender, address(this), amountDeposited),\n            'Could not deposit ERC20s'\n        );\n        holdings[destination] = holdings[destination].add(amountDeposited);\n        emit Deposited(destination, amountDeposited, holdings[destination]);\n    }\n\n    /**\n     * @notice Transfers the given amount of ERC20 tokens to a supplied ethereum address.\n     * @dev Transfers the given amount of ERC20 tokens to a supplied ethereum address.\n     * @param destination Ethereum address to be credited.\n     * @param amount Quantity of tokens to be transferred.\n     */\n    function _transferAsset(address payable destination, uint256 amount) internal virtual override {\n        Token.transfer(destination, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20MinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\n/**\n * @dev This contract extends an ERC20 implementation, and mints 10,000 tokens to the deploying account. Used for testing purposes.\n */\ncontract Token is ERC20 {\n    /**\n     * @dev Constructor function minting 10,000 tokens to the msg.sender (deploying account).\n     */\n    constructor(uint256) public ERC20('TestToken', 'TEST') {\n        _mint(msg.sender, 10000);\n    }\n}\n"
    },
    "contracts/test/TESTAssetHolder2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport './TESTAssetHolder.sol';\n\n/**\n * @dev This contract is a clone of the TESTAssetHolder contract. It is used for testing purposes only, to enable testing of transferAll and claimAll in multiple AssetHolders. It has a dummy storage variable in order to change the ABI. TODO remove the need for this contract by allowing TESTAssetHolder to be deployed twice.\n */\ncontract TESTAssetHolder2 is TESTAssetHolder {\n    /**\n     * @notice Constructor function storing the AdjudicatorAddress.\n     * @dev Constructor function storing the AdjudicatorAddress.\n     * @param _AdjudicatorAddress Address of an Adjudicator  contract, supplied at deploy-time.\n     */\n    constructor(address _AdjudicatorAddress) public TESTAssetHolder(_AdjudicatorAddress) {}\n\n    bool public dummy;\n}\n"
    },
    "contracts/NitroAdjudicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/Adjudicator.sol';\nimport './ForceMove.sol';\nimport './Outcome.sol';\nimport './AssetHolder.sol';\n\n/**\n * @dev The NitroAdjudicator contract extends ForceMove and hence inherits all ForceMove methods, and also extends and implements the Adjudicator interface, allowing for a finalized outcome to be pushed to an asset holder.\n */\ncontract NitroAdjudicator is Adjudicator, ForceMove {\n    /**\n     * @notice Allows a finalized channel's outcome to be decoded and one or more AssetOutcomes registered in external Asset Holder contracts.\n     * @dev Allows a finalized channel's outcome to be decoded and one or more AssetOutcomes registered in external Asset Holder contracts.\n     * @param channelId Unique identifier for a state channel\n     * @param turnNumRecord A turnNum that (the adjudicator knows and stores) is supported by a signature from each participant.\n     * @param finalizesAt The unix timestamp when this channel will finalize\n     * @param stateHash The keccak256 of the abi.encode of the State (struct) stored by the adjudicator\n     * @param challengerAddress The address of the participant whom registered the challenge, if any.\n     * @param outcomeBytes The encoded Outcome of this state channel.\n     */\n    function pushOutcome(\n        bytes32 channelId,\n        uint48 turnNumRecord,\n        uint48 finalizesAt,\n        bytes32 stateHash,\n        address challengerAddress,\n        bytes memory outcomeBytes\n    ) public override {\n        // requirements\n        _requireChannelFinalized(channelId);\n\n        bytes32 outcomeHash = keccak256(abi.encode(outcomeBytes));\n\n        _requireMatchingStorage(\n            ChannelData(turnNumRecord, finalizesAt, stateHash, challengerAddress, outcomeHash),\n            channelId\n        );\n\n        Outcome.OutcomeItem[] memory outcome = abi.decode(outcomeBytes, (Outcome.OutcomeItem[]));\n\n        for (uint256 i = 0; i < outcome.length; i++) {\n            require(\n                AssetHolder(outcome[i].assetHolderAddress).setAssetOutcomeHash(\n                    channelId,\n                    keccak256(outcome[i].assetOutcomeBytes)\n                )\n            );\n        }\n    }\n\n    /**\n     * @notice Allows a finalized channel's outcome to be decoded and transferAll to be triggered in external Asset Holder contracts.\n     * @dev Allows a finalized channel's outcome to be decoded and one or more AssetOutcomes registered in external Asset Holder contracts.\n     * @param channelId Unique identifier for a state channel\n     * @param turnNumRecord A turnNum that (the adjudicator knows and stores) is supported by a signature from each participant.\n     * @param finalizesAt The unix timestamp when this channel will finalize\n     * @param stateHash The keccak256 of the abi.encode of the State (struct) stored by the adjudicator\n     * @param challengerAddress The address of the participant whom registered the challenge, if any.\n     * @param outcomeBytes The encoded Outcome of this state channel.\n     */\n    function pushOutcomeAndTransferAll(\n        bytes32 channelId,\n        uint48 turnNumRecord,\n        uint48 finalizesAt,\n        bytes32 stateHash,\n        address challengerAddress,\n        bytes memory outcomeBytes\n    ) public {\n        // requirements\n        _requireChannelFinalized(channelId);\n\n        bytes32 outcomeHash = keccak256(abi.encode(outcomeBytes));\n\n        _requireMatchingStorage(\n            ChannelData(turnNumRecord, finalizesAt, stateHash, challengerAddress, outcomeHash),\n            channelId\n        );\n\n        _transferAllFromAllAssetHolders(channelId, outcomeBytes);\n    }\n\n    /**\n     * @notice Finalizes a channel by providing a finalization proof, allows a finalized channel's outcome to be decoded and transferAll to be triggered in external Asset Holder contracts.\n     * @dev Finalizes a channel by providing a finalization proof, allows a finalized channel's outcome to be decoded and transferAll to be triggered in external Asset Holder contracts.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param appPartHash The keccak256 of the abi.encode of `(challengeDuration, appDefinition, appData)`. Applies to all states in the finalization proof.\n     * @param outcomeBytes abi.encode of an array of Outcome.OutcomeItem structs.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     */\n    function concludePushOutcomeAndTransferAll(\n        uint48 largestTurnNum,\n        FixedPart memory fixedPart,\n        bytes32 appPartHash,\n        bytes memory outcomeBytes,\n        uint8 numStates,\n        uint8[] memory whoSignedWhat,\n        Signature[] memory sigs\n    ) public {\n        // requirements\n        bytes32 channelId = _getChannelId(fixedPart);\n\n        _requireChannelNotFinalized(channelId);\n\n        // By construction, the following states form a valid transition\n        bytes32[] memory stateHashes = new bytes32[](numStates);\n\n        bytes32 outcomeHash = keccak256(abi.encode(outcomeBytes));\n        for (uint48 i = 0; i < numStates; i++) {\n            stateHashes[i] = keccak256(\n                abi.encode(\n                    State(\n                        largestTurnNum + (i + 1) - numStates, // turnNum\n                        true, // isFinal\n                        channelId,\n                        appPartHash,\n                        outcomeHash\n                    )\n                )\n            );\n        }\n\n        require(\n            _validSignatures(\n                largestTurnNum,\n                fixedPart.participants,\n                stateHashes,\n                sigs,\n                whoSignedWhat\n            ),\n            'Invalid signatures'\n        );\n\n        // effects\n\n        channelStorageHashes[channelId] = _hashChannelData(\n            ChannelData(0, uint48(now), bytes32(0), address(0), outcomeHash)\n        );\n        emit Concluded(channelId);\n\n        _transferAllFromAllAssetHolders(channelId, outcomeBytes);\n    }\n\n    /**\n     * @notice Triggers transferAll in all external Asset Holder contracts specified in a given outcome for a given channelId.\n     * @dev Triggers transferAll in  all external Asset Holder contracts specified in a given outcome for a given channelId.\n     * @param channelId Unique identifier for a state channel\n     * @param outcomeBytes abi.encode of an array of Outcome.OutcomeItem structs.\n     */\n    function _transferAllFromAllAssetHolders(bytes32 channelId, bytes memory outcomeBytes)\n        internal\n    {\n        Outcome.OutcomeItem[] memory outcome = abi.decode(outcomeBytes, (Outcome.OutcomeItem[]));\n\n        for (uint256 i = 0; i < outcome.length; i++) {\n            Outcome.AssetOutcome memory assetOutcome = abi.decode(\n                outcome[i].assetOutcomeBytes,\n                (Outcome.AssetOutcome)\n            );\n            if (assetOutcome.assetOutcomeType == uint8(Outcome.AssetOutcomeType.Allocation)) {\n                AssetHolder(outcome[i].assetHolderAddress).transferAllAdjudicatorOnly(\n                    channelId,\n                    assetOutcome.allocationOrGuaranteeBytes\n                );\n            } else {\n                revert('_transferAllFromAllAssetHolders: AssetOutcomeType is not an allocation');\n            }\n        }\n    }\n\n    /**\n    * @notice Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)\n    * @dev Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)\n    * @param nParticipants Number of participants in the channel.\n    transition\n    * @param isFinalAB Pair of booleans denoting whether the first and second state (resp.) are final.\n    * @param ab Variable parts of each of the pair of states\n    * @param turnNumB turnNum of the later state of the pair.\n    * @param appDefinition Address of deployed contract containing application-specific validTransition function.\n    * @return true if the later state is a validTransition from its predecessor, reverts otherwise.\n    */\n    function validTransition(\n        uint256 nParticipants,\n        bool[2] memory isFinalAB, // [a.isFinal, b.isFinal]\n        ForceMoveApp.VariablePart[2] memory ab, // [a,b]\n        uint48 turnNumB,\n        address appDefinition\n    ) public pure returns (bool) {\n        return _requireValidTransition(nParticipants, isFinalAB, ab, turnNumB, appDefinition);\n    }\n}\n"
    },
    "contracts/interfaces/Adjudicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev An Adjudicator Interface calls for a method that allows a finalized outcome to be pushed to an asset holder.\n */\ninterface Adjudicator {\n    /**\n     * @notice Allows a finalized channel's outcome to be decoded and one or more AssetOutcomes registered in external Asset Holder contracts.\n     * @dev Allows a finalized channel's outcome to be decoded and one or more AssetOutcomes registered in external Asset Holder contracts.\n     * @param channelId Unique identifier for a state channel\n     * @param turnNumRecord A turnNum that (the adjudicator knows and stores) is supported by a signature from each participant.\n     * @param finalizesAt The unix timestamp when this channel will finalize\n     * @param stateHash The keccak256 of the abi.encode of the State (struct) stored by the adjudicator\n     * @param challengerAddress The address of the participant whom registered the challenge, if any.\n     * @param outcomeBytes The encoded Outcome of this state channel.\n     */\n    function pushOutcome(\n        bytes32 channelId,\n        uint48 turnNumRecord,\n        uint48 finalizesAt,\n        bytes32 stateHash,\n        address challengerAddress,\n        bytes calldata outcomeBytes\n    ) external;\n}\n"
    },
    "contracts/ForceMove.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/IForceMove.sol';\nimport './interfaces/ForceMoveApp.sol';\n\n/**\n * @dev An implementation of ForceMove protocol, which allows state channels to be adjudicated and finalized.\n */\ncontract ForceMove is IForceMove {\n    mapping(bytes32 => bytes32) public channelStorageHashes;\n\n    // Public methods:\n\n    /**\n     * @notice Unpacks turnNumRecord, finalizesAt and fingerprint from the channelStorageHash of a particular channel.\n     * @dev Unpacks turnNumRecord, finalizesAt and fingerprint from the channelStorageHash of a particular channel.\n     * @param channelId Unique identifier for a state channel.\n     * @return turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     * @return finalizesAt The unix timestamp when `channelId` will finalize.\n     * @return fingerprint Unique identifier for the channel's current state, up to hash collisions.\n     */\n    function getChannelStorage(bytes32 channelId)\n        public\n        view\n        returns (\n            uint48 turnNumRecord,\n            uint48 finalizesAt,\n            uint160 fingerprint\n        )\n    {\n        (turnNumRecord, finalizesAt, fingerprint) = _getChannelStorage(channelId);\n    }\n\n    /**\n     * @notice Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @dev Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update. Length is from 1 to the number of participants (inclusive).\n     * @param isFinalCount Describes how many of the submitted states have the `isFinal` property set to `true`. It is implied that the rightmost `isFinalCount` states are final, and the rest are not final.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`. There must be one for each participant, e.g.: [sig-from-p0, sig-from-p1, ...]\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param challengerSig The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\n     */\n    function challenge(\n        FixedPart memory fixedPart,\n        uint48 largestTurnNum,\n        ForceMoveApp.VariablePart[] memory variableParts,\n        uint8 isFinalCount, // how many of the states are final\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat,\n        Signature memory challengerSig\n    ) public override {\n        bytes32 channelId = _getChannelId(fixedPart);\n\n        if (_mode(channelId) == ChannelMode.Open) {\n            _requireNonDecreasedTurnNumber(channelId, largestTurnNum);\n        } else if (_mode(channelId) == ChannelMode.Challenge) {\n            _requireIncreasedTurnNumber(channelId, largestTurnNum);\n        } else {\n            // This should revert.\n            _requireChannelNotFinalized(channelId);\n        }\n        bytes32 supportedStateHash = _requireStateSupportedBy(\n            largestTurnNum,\n            variableParts,\n            isFinalCount,\n            channelId,\n            fixedPart,\n            sigs,\n            whoSignedWhat\n        );\n\n        address challenger = _requireChallengerIsParticipant(\n            supportedStateHash,\n            fixedPart.participants,\n            challengerSig\n        );\n\n        // effects\n\n        emit ChallengeRegistered(\n            channelId,\n            largestTurnNum,\n            uint48(now) + fixedPart.challengeDuration, // This could overflow, so don't join a channel with a huge challengeDuration\n            challenger,\n            isFinalCount > 0,\n            fixedPart,\n            variableParts,\n            sigs,\n            whoSignedWhat\n        );\n\n        channelStorageHashes[channelId] = _hashChannelData(\n            ChannelData(\n                largestTurnNum,\n                uint48(now) + fixedPart.challengeDuration,\n                supportedStateHash,\n                challenger,\n                keccak256(abi.encode(variableParts[variableParts.length - 1].outcome))\n            )\n        );\n    }\n\n    /**\n     * @notice Repsonds to an ongoing challenge registered against a state channel.\n     * @dev Repsonds to an ongoing challenge registered against a state channel.\n     * @param challenger The address of the participant whom registered the challenge.\n     * @param isFinalAB An pair of booleans describing if the challenge state and/or the response state have the `isFinal` property set to `true`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variablePartAB An pair of structs, each decribing the properties of the state channel that may change with each state update (for the challenge state and for the response state).\n     * @param sig The responder's signature on the `responseStateHash`.\n     */\n    function respond(\n        address challenger,\n        bool[2] memory isFinalAB,\n        FixedPart memory fixedPart,\n        ForceMoveApp.VariablePart[2] memory variablePartAB,\n        // variablePartAB[0] = challengeVariablePart\n        // variablePartAB[1] = responseVariablePart\n        Signature memory sig\n    ) public override {\n        bytes32 channelId = _getChannelId(fixedPart);\n        (uint48 turnNumRecord, uint48 finalizesAt, ) = _getChannelStorage(channelId);\n\n        bytes32 challengeOutcomeHash = _hashOutcome(variablePartAB[0].outcome);\n        bytes32 responseOutcomeHash = _hashOutcome(variablePartAB[1].outcome);\n        bytes32 challengeStateHash = _hashState(\n            turnNumRecord,\n            isFinalAB[0],\n            channelId,\n            fixedPart,\n            variablePartAB[0].appData,\n            challengeOutcomeHash\n        );\n\n        bytes32 responseStateHash = _hashState(\n            turnNumRecord + 1,\n            isFinalAB[1],\n            channelId,\n            fixedPart,\n            variablePartAB[1].appData,\n            responseOutcomeHash\n        );\n\n        // checks\n\n        _requireSpecificChallenge(\n            ChannelData(\n                turnNumRecord,\n                finalizesAt,\n                challengeStateHash,\n                challenger,\n                challengeOutcomeHash\n            ),\n            channelId\n        );\n\n        require(\n            _recoverSigner(responseStateHash, sig) ==\n                fixedPart.participants[(turnNumRecord + 1) % fixedPart.participants.length],\n            'Response not signed by authorized mover'\n        );\n\n        _requireValidTransition(\n            fixedPart.participants.length,\n            isFinalAB,\n            variablePartAB,\n            turnNumRecord + 1,\n            fixedPart.appDefinition\n        );\n\n        // effects\n        _clearChallenge(channelId, turnNumRecord + 1);\n    }\n\n    /**\n     * @notice Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @dev Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param isFinalCount Describes how many of the submitted states have the `isFinal` property set to `true`. It is implied that the rightmost `isFinalCount` states are final, and the rest are not final.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     */\n    function checkpoint(\n        FixedPart memory fixedPart,\n        uint48 largestTurnNum,\n        ForceMoveApp.VariablePart[] memory variableParts,\n        uint8 isFinalCount, // how many of the states are final\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat\n    ) public override {\n        bytes32 channelId = _getChannelId(fixedPart);\n\n        // checks\n        _requireChannelNotFinalized(channelId);\n        _requireIncreasedTurnNumber(channelId, largestTurnNum);\n        _requireStateSupportedBy(\n            largestTurnNum,\n            variableParts,\n            isFinalCount,\n            channelId,\n            fixedPart,\n            sigs,\n            whoSignedWhat\n        );\n\n        // effects\n        _clearChallenge(channelId, largestTurnNum);\n    }\n\n    /**\n     * @notice Finalizes a channel by providing a finalization proof.\n     * @dev Finalizes a channel by providing a finalization proof.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param appPartHash The keccak256 of the abi.encode of `(challengeDuration, appDefinition, appData)`. Applies to all states in the finalization proof.\n     * @param outcomeHash The keccak256 of the abi.encode of the `outcome`. Applies to all stats in the finalization proof.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     */\n    function conclude(\n        uint48 largestTurnNum,\n        FixedPart memory fixedPart,\n        bytes32 appPartHash,\n        bytes32 outcomeHash,\n        uint8 numStates,\n        uint8[] memory whoSignedWhat,\n        Signature[] memory sigs\n    ) public override {\n        bytes32 channelId = _getChannelId(fixedPart);\n        _requireChannelNotFinalized(channelId);\n\n        require(\n            largestTurnNum + 1 >= numStates,\n            'largestTurnNum + 1 must be greater than or equal to numStates'\n        );\n        // ^^ SW-C101: prevent underflow\n\n        // By construction, the following states form a valid transition\n        bytes32[] memory stateHashes = new bytes32[](numStates);\n        for (uint48 i = 0; i < numStates; i++) {\n            stateHashes[i] = keccak256(\n                abi.encode(\n                    State(\n                        largestTurnNum + (i + 1) - numStates, // turnNum\n                        // ^^ SW-C101: It is not easy to use SafeMath here, since we are not using uint256s\n                        // Instead, we are protected by the require statement above\n                        true, // isFinal\n                        channelId,\n                        appPartHash,\n                        outcomeHash\n                    )\n                )\n            );\n        }\n\n        // checks\n        require(\n            _validSignatures(\n                largestTurnNum,\n                fixedPart.participants,\n                stateHashes,\n                sigs,\n                whoSignedWhat\n            ),\n            'Invalid signatures OR isFinal=true expected'\n        );\n\n        // effects\n        channelStorageHashes[channelId] = _hashChannelData(\n            ChannelData(0, uint48(now), bytes32(0), address(0), outcomeHash)\n        );\n        emit Concluded(channelId);\n    }\n\n    // Internal methods:\n\n    /**\n     * @notice Checks that the challengerSignature was created by one of the supplied participants.\n     * @dev Checks that the challengerSignature was created by one of the supplied participants.\n     * @param supportedStateHash Forms part of the digest to be signed, along with the string 'forceMove'.\n     * @param participants A list of addresses representing the participants of a channel.\n     * @param challengerSignature The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\n     */\n    function _requireChallengerIsParticipant(\n        bytes32 supportedStateHash,\n        address[] memory participants,\n        Signature memory challengerSignature\n    ) internal pure returns (address challenger) {\n        challenger = _recoverSigner(\n            keccak256(abi.encode(supportedStateHash, 'forceMove')),\n            challengerSignature\n        );\n        require(_isAddressInArray(challenger, participants), 'Challenger is not a participant');\n    }\n\n    /**\n     * @notice Tests whether a given address is in a given array of addresses.\n     * @dev Tests whether a given address is in a given array of addresses.\n     * @param suspect A single address of interest.\n     * @param addresses A line-up of possible perpetrators.\n     * @return true if the address is in the array, false otherwise\n     */\n    function _isAddressInArray(address suspect, address[] memory addresses)\n        internal\n        pure\n        returns (bool)\n    {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (suspect == addresses[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @dev Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param participants A list of addresses representing the participants of a channel.\n     * @param stateHashes Array of keccak256(State) submitted in support of a state,\n     * @param sigs Array of Signatures, one for each participant\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @return true if the signatures are valid, false otherwise\n     */\n    function _validSignatures(\n        uint48 largestTurnNum,\n        address[] memory participants,\n        bytes32[] memory stateHashes,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat // whoSignedWhat[i] is the index of the state in stateHashes that was signed by participants[i]\n    ) internal pure returns (bool) {\n        uint256 nParticipants = participants.length;\n        uint256 nStates = stateHashes.length;\n\n        require(\n            _acceptableWhoSignedWhat(whoSignedWhat, largestTurnNum, nParticipants, nStates),\n            'Unacceptable whoSignedWhat array'\n        );\n        for (uint256 i = 0; i < nParticipants; i++) {\n            address signer = _recoverSigner(stateHashes[whoSignedWhat[i]], sigs[i]);\n            if (signer != participants[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @dev Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @param largestTurnNum Largest turnNum of the support proof\n     * @param nParticipants Number of participants in the channel\n     * @param nStates Number of states in the support proof\n     * @return true if whoSignedWhat is acceptable, false otherwise\n     */\n    function _acceptableWhoSignedWhat(\n        uint8[] memory whoSignedWhat,\n        uint48 largestTurnNum,\n        uint256 nParticipants,\n        uint256 nStates\n    ) internal pure returns (bool) {\n        require(\n            whoSignedWhat.length == nParticipants,\n            '_validSignatures: whoSignedWhat must be the same length as participants'\n        );\n        for (uint256 i = 0; i < nParticipants; i++) {\n            uint256 offset = (nParticipants + largestTurnNum - i) % nParticipants;\n            // offset is the difference between the index of participant[i] and the index of the participant who owns the largesTurnNum state\n            // the additional nParticipants in the dividend ensures offset always positive\n            if (whoSignedWhat[i] + offset + 1 < nStates) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bytes constant prefix = '\\x19Ethereum Signed Message:\\n32';\n\n    /**\n     * @notice Given a digest and ethereum digital signature, recover the signer\n     * @dev Given a digest and digital signature, recover the signer\n     * @param _d message digest\n     * @param sig ethereum digital signature\n     * @return signer\n     */\n    function _recoverSigner(bytes32 _d, Signature memory sig) internal pure returns (address) {\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _d));\n        address a = ecrecover(prefixedHash, sig.v, sig.r, sig.s);\n        return (a);\n    }\n\n    /**\n     * @notice Check that the submitted data constitute a support proof.\n     * @dev Check that the submitted data constitute a support proof.\n     * @param largestTurnNum Largest turnNum of the support proof\n     * @param variableParts Variable parts of the states in the support proof\n     * @param isFinalCount How many of the states are final? The final isFinalCount states are implied final, the remainder are implied not final.\n     * @param channelId Unique identifier for a channel.\n     * @param fixedPart Fixed Part of the states in the support proof\n     * @param sigs A signature from each participant.\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @return The hash of the latest state in the proof, if supported, else reverts.\n     */\n    function _requireStateSupportedBy(\n        uint48 largestTurnNum,\n        ForceMoveApp.VariablePart[] memory variableParts,\n        uint8 isFinalCount,\n        bytes32 channelId,\n        FixedPart memory fixedPart,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat\n    ) internal pure returns (bytes32) {\n        bytes32[] memory stateHashes = _requireValidTransitionChain(\n            largestTurnNum,\n            variableParts,\n            isFinalCount,\n            channelId,\n            fixedPart\n        );\n\n        require(\n            _validSignatures(\n                largestTurnNum,\n                fixedPart.participants,\n                stateHashes,\n                sigs,\n                whoSignedWhat\n            ),\n            'Invalid signatures'\n        );\n\n        return stateHashes[stateHashes.length - 1];\n    }\n\n    /**\n     * @notice Check that the submitted states form a chain of valid transitions\n     * @dev Check that the submitted states form a chain of valid transitions\n     * @param largestTurnNum Largest turnNum of the support proof\n     * @param variableParts Variable parts of the states in the support proof\n     * @param isFinalCount How many of the states are final? The final isFinalCount states are implied final, the remainder are implied not final.\n     * @param channelId Unique identifier for a channel.\n     * @param fixedPart Fixed Part of the states in the support proof\n     * @return true if every state is a validTransition from its predecessor, false otherwise.\n     */\n    function _requireValidTransitionChain(\n        // returns stateHashes array if valid\n        // else, reverts\n        uint48 largestTurnNum,\n        ForceMoveApp.VariablePart[] memory variableParts,\n        uint8 isFinalCount,\n        bytes32 channelId,\n        FixedPart memory fixedPart\n    ) internal pure returns (bytes32[] memory) {\n        bytes32[] memory stateHashes = new bytes32[](variableParts.length);\n        uint48 firstFinalTurnNum = largestTurnNum - isFinalCount + 1;\n        uint48 turnNum;\n\n        for (uint48 i = 0; i < variableParts.length; i++) {\n            turnNum = largestTurnNum - uint48(variableParts.length) + 1 + i;\n            stateHashes[i] = _hashState(\n                turnNum,\n                turnNum >= firstFinalTurnNum,\n                channelId,\n                fixedPart,\n                variableParts[i].appData,\n                _hashOutcome(variableParts[i].outcome)\n            );\n            if (turnNum < largestTurnNum) {\n                _requireValidTransition(\n                    fixedPart.participants.length,\n                    [turnNum >= firstFinalTurnNum, turnNum + 1 >= firstFinalTurnNum],\n                    [variableParts[i], variableParts[i + 1]],\n                    turnNum + 1,\n                    fixedPart.appDefinition\n                );\n            }\n        }\n        return stateHashes;\n    }\n\n    /**\n    * @notice Check that the submitted pair of states form a valid transition\n    * @dev Check that the submitted pair of states form a valid transition\n    * @param nParticipants Number of participants in the channel.\n    transition\n    * @param isFinalAB Pair of booleans denoting whether the first and second state (resp.) are final.\n    * @param ab Variable parts of each of the pair of states\n    * @param turnNumB turnNum of the later state of the pair.\n    * @param appDefinition Address of deployed contract containing application-specific validTransition function.\n    * @return true if the later state is a validTransition from its predecessor, false otherwise.\n    */\n    function _requireValidTransition(\n        uint256 nParticipants,\n        bool[2] memory isFinalAB, // [a.isFinal, b.isFinal]\n        ForceMoveApp.VariablePart[2] memory ab, // [a,b]\n        uint48 turnNumB,\n        address appDefinition\n    ) internal pure returns (bool) {\n        // a prior check on the signatures for the submitted states implies that the following fields are equal for a and b:\n        // chainId, participants, channelNonce, appDefinition, challengeDuration\n        // and that the b.turnNum = a.turnNum + 1\n        if (isFinalAB[1]) {\n            require(\n                _bytesEqual(ab[1].outcome, ab[0].outcome),\n                'InvalidTransitionError: Cannot move to a final state with a different default outcome'\n            );\n        } else {\n            require(\n                !isFinalAB[0],\n                'InvalidTransitionError: Cannot move from a final state to a non final state'\n            );\n            if (turnNumB < 2 * nParticipants) {\n                require(\n                    _bytesEqual(ab[1].outcome, ab[0].outcome),\n                    'InvalidTransitionError: Cannot change the default outcome during setup phase'\n                );\n                require(\n                    _bytesEqual(ab[1].appData, ab[0].appData),\n                    'InvalidTransitionError: Cannot change the appData during setup phase'\n                );\n            } else {\n                require(\n                    ForceMoveApp(appDefinition).validTransition(\n                        ab[0],\n                        ab[1],\n                        turnNumB,\n                        nParticipants\n                    )\n                );\n                // reason string not necessary (called function will provide reason for reverting)\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Check for equality of two byte strings\n     * @dev Check for equality of two byte strings\n     * @param _preBytes One bytes string\n     * @param _postBytes The other bytes string\n     * @return true if the bytes are identical, false otherwise.\n     */\n    function _bytesEqual(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bool)\n    {\n        // copied from https://www.npmjs.com/package/solidity-bytes-utils/v/0.1.1\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n                case 1 {\n                    // cb is a circuit breaker in the for loop since there's\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don't breaker\n                    // cb = 0 - break\n                    let cb := 1\n\n                    let mc := add(_preBytes, 0x20)\n                    let end := add(mc, length)\n\n                    for {\n                        let cc := add(_postBytes, 0x20)\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                    } eq(add(lt(mc, end), cb), 2) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        // if any of these checks fails then arrays are not equal\n                        if iszero(eq(mload(mc), mload(cc))) {\n                            // unsuccess:\n                            success := 0\n                            cb := 0\n                        }\n                    }\n                }\n                default {\n                    // unsuccess:\n                    success := 0\n                }\n        }\n\n        return success;\n    }\n\n    /**\n     * @notice Clears a challenge by updating the turnNumRecord and resetting the remaining channel storage fields, and emits a ChallengeCleared event.\n     * @dev Clears a challenge by updating the turnNumRecord and resetting the remaining channel storage fields, and emits a ChallengeCleared event.\n     * @param channelId Unique identifier for a channel.\n     * @param newTurnNumRecord New turnNumRecord to overwrite existing value\n     */\n    function _clearChallenge(bytes32 channelId, uint48 newTurnNumRecord) internal {\n        channelStorageHashes[channelId] = _hashChannelData(\n            ChannelData(newTurnNumRecord, 0, bytes32(0), address(0), bytes32(0))\n        );\n        emit ChallengeCleared(channelId, newTurnNumRecord);\n    }\n\n    /**\n     * @notice Checks that the submitted turnNumRecord is strictly greater than the turnNumRecord stored on chain.\n     * @dev Checks that the submitted turnNumRecord is strictly greater than the turnNumRecord stored on chain.\n     * @param channelId Unique identifier for a channel.\n     * @param newTurnNumRecord New turnNumRecord intended to overwrite existing value\n     */\n    function _requireIncreasedTurnNumber(bytes32 channelId, uint48 newTurnNumRecord) internal view {\n        (uint48 turnNumRecord, , ) = _getChannelStorage(channelId);\n        require(newTurnNumRecord > turnNumRecord, 'turnNumRecord not increased.');\n    }\n\n    /**\n     * @notice Checks that the submitted turnNumRecord is greater than or equal to the turnNumRecord stored on chain.\n     * @dev Checks that the submitted turnNumRecord is greater than or equal to the turnNumRecord stored on chain.\n     * @param channelId Unique identifier for a channel.\n     * @param newTurnNumRecord New turnNumRecord intended to overwrite existing value\n     */\n    function _requireNonDecreasedTurnNumber(bytes32 channelId, uint48 newTurnNumRecord)\n        internal\n        view\n    {\n        (uint48 turnNumRecord, , ) = _getChannelStorage(channelId);\n        require(newTurnNumRecord >= turnNumRecord, 'turnNumRecord decreased.');\n    }\n\n    /**\n     * @notice Checks that a given ChannelData struct matches the challenge stored on chain, and that the channel is in Challenge mode.\n     * @dev Checks that a given ChannelData struct matches the challenge stored on chain, and that the channel is in Challenge mode.\n     * @param data A given ChannelData data structure.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireSpecificChallenge(ChannelData memory data, bytes32 channelId) internal view {\n        _requireMatchingStorage(data, channelId);\n        _requireOngoingChallenge(channelId);\n    }\n\n    /**\n     * @notice Checks that a given channel is in the Challenge mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireOngoingChallenge(bytes32 channelId) internal view {\n        require(_mode(channelId) == ChannelMode.Challenge, 'No ongoing challenge.');\n    }\n\n    /**\n     * @notice Checks that a given channel is NOT in the Finalized mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireChannelNotFinalized(bytes32 channelId) internal view {\n        require(_mode(channelId) != ChannelMode.Finalized, 'Channel finalized.');\n    }\n\n    /**\n     * @notice Checks that a given channel is in the Finalized mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireChannelFinalized(bytes32 channelId) internal view {\n        require(_mode(channelId) == ChannelMode.Finalized, 'Channel not finalized.');\n    }\n\n    /**\n     * @notice Checks that a given channel is in the Open mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireChannelOpen(bytes32 channelId) internal view {\n        require(_mode(channelId) == ChannelMode.Open, 'Channel not open.');\n    }\n\n    /**\n     * @notice Checks that a given ChannelData struct matches the challenge stored on chain.\n     * @dev Checks that a given ChannelData struct matches the challenge stored on chain.\n     * @param data A given ChannelData data structure.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireMatchingStorage(ChannelData memory data, bytes32 channelId) internal view {\n        require(\n            _matchesHash(data, channelStorageHashes[channelId]),\n            'Channel storage does not match stored version.'\n        );\n    }\n\n    /**\n     * @notice Computes the ChannelMode for a given channelId.\n     * @dev Computes the ChannelMode for a given channelId.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _mode(bytes32 channelId) internal view returns (ChannelMode) {\n        // Note that _getChannelStorage(someRandomChannelId) returns (0,0,0), which is\n        // correct when nobody has written to storage yet.\n\n        (, uint48 finalizesAt, ) = _getChannelStorage(channelId);\n        if (finalizesAt == 0) {\n            return ChannelMode.Open;\n        } else if (finalizesAt <= now) {\n            return ChannelMode.Finalized;\n        } else {\n            return ChannelMode.Challenge;\n        }\n    }\n\n    /**\n     * @notice Hashes the input data and formats it for on chain storage.\n     * @dev Hashes the input data and formats it for on chain storage.\n     * @param channelData ChannelData data.\n     */\n    function _hashChannelData(ChannelData memory channelData)\n        internal\n        pure\n        returns (bytes32 newHash)\n    {\n        // The hash is constructed from left to right.\n        uint256 result;\n        uint16 cursor = 256;\n\n        // Shift turnNumRecord 208 bits left to fill the first 48 bits\n        result = uint256(channelData.turnNumRecord) << (cursor -= 48);\n\n        // logical or with finalizesAt padded with 160 zeros to get the next 48 bits\n        result |= (uint256(channelData.finalizesAt) << (cursor -= 48));\n\n        // logical or with the last 160 bits of the hash of the encoded storage\n        result |= uint256(uint160(uint256(keccak256(abi.encode(channelData)))));\n\n        newHash = bytes32(result);\n    }\n\n    /**\n     * @notice Unpacks turnNumRecord, finalizesAt and fingerprint from the channelStorageHash of a particular channel.\n     * @dev Unpacks turnNumRecord, finalizesAt and fingerprint from the channelStorageHash of a particular channel.\n     * @param channelId Unique identifier for a state channel.\n     * @return turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     * @return finalizesAt The unix timestamp when `channelId` will finalize.\n     * @return fingerprint Unique identifier for the channel's current state, up to hash collisions.\n     */\n    function _getChannelStorage(bytes32 channelId)\n        internal\n        view\n        returns (\n            uint48 turnNumRecord,\n            uint48 finalizesAt,\n            uint160 fingerprint\n        )\n    {\n        bytes32 storageHash = channelStorageHashes[channelId];\n        uint16 cursor = 256;\n        turnNumRecord = uint48(uint256(storageHash) >> (cursor -= 48));\n        finalizesAt = uint48(uint256(storageHash) >> (cursor -= 48));\n        fingerprint = uint160(uint256(storageHash));\n    }\n\n    /**\n     * @notice Checks that a given ChannelData struct matches a supplied bytes32 when formatted for storage.\n     * @dev Checks that a given ChannelData struct matches a supplied bytes32 when formatted for storage.\n     * @param data A given ChannelData data structure.\n     * @param h Some data in on-chain storage format.\n     */\n    function _matchesHash(ChannelData memory data, bytes32 h) internal pure returns (bool) {\n        return _hashChannelData(data) == h;\n    }\n\n    /**\n     * @notice Computes the hash of the state corresponding to the input data.\n     * @dev Computes the hash of the state corresponding to the input data.\n     * @param turnNum Turn number\n     * @param isFinal Is the state final?\n     * @param channelId Unique identifier for the channel\n     * @param fixedPart Part of the state that does not change\n     * @param appData Application specific date\n     * @param outcomeHash Hash of the outcome.\n     * @return The stateHash\n     */\n    function _hashState(\n        uint48 turnNum,\n        bool isFinal,\n        bytes32 channelId,\n        FixedPart memory fixedPart,\n        bytes memory appData,\n        bytes32 outcomeHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    State(\n                        turnNum,\n                        isFinal,\n                        channelId,\n                        keccak256(\n                            abi.encode(\n                                fixedPart.challengeDuration,\n                                fixedPart.appDefinition,\n                                appData\n                            )\n                        ),\n                        outcomeHash\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Computes the hash of a given outcome.\n     * @dev Computes the hash of a given outcome.\n     * @param outcome An outcome\n     * @return The outcomeHash\n     */\n    function _hashOutcome(bytes memory outcome) internal pure returns (bytes32) {\n        return keccak256(abi.encode(outcome));\n    }\n\n    /**\n     * @notice Computes the unique id of a channel.\n     * @dev Computes the unique id of a channel.\n     * @param fixedPart Part of the state that does not change\n     * @return channelId\n     */\n    function _getChannelId(FixedPart memory fixedPart) internal pure returns (bytes32 channelId) {\n        channelId = keccak256(\n            abi.encode(fixedPart.chainId, fixedPart.participants, fixedPart.channelNonce)\n        );\n    }\n\n    // events\n    event ChallengeRegistered(\n        bytes32 indexed channelId,\n        // everything needed to respond or checkpoint\n        uint48 turnNumRecord,\n        uint48 finalizesAt,\n        address challenger,\n        bool isFinal,\n        FixedPart fixedPart,\n        ForceMoveApp.VariablePart[] variableParts,\n        Signature[] sigs,\n        uint8[] whoSignedWhat\n    );\n\n    event ChallengeCleared(bytes32 indexed channelId, uint48 newTurnNumRecord);\n    event Concluded(bytes32 indexed channelId);\n}\n"
    },
    "contracts/interfaces/IForceMove.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport './ForceMoveApp.sol';\n\n/**\n * @dev The IForceMove contract abstraction defines the interface that an implementation of ForceMove should implement. ForceMove protocol allows state channels to be adjudicated and finalized.\n */\nabstract contract IForceMove {\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct FixedPart {\n        uint256 chainId;\n        address[] participants;\n        uint48 channelNonce;\n        address appDefinition;\n        uint48 challengeDuration;\n    }\n\n    struct State {\n        // participants sign the hash of this\n        uint48 turnNum;\n        bool isFinal;\n        bytes32 channelId; // keccack(chainId,participants,channelNonce)\n        bytes32 appPartHash;\n        //     keccak256(abi.encode(\n        //         fixedPart.challengeDuration,\n        //         fixedPart.appDefinition,\n        //         variablePart.appData\n        //     )\n        // )\n        bytes32 outcomeHash;\n    }\n\n    struct ChannelData {\n        uint48 turnNumRecord;\n        uint48 finalizesAt;\n        bytes32 stateHash; // keccak256(abi.encode(State))\n        address challengerAddress;\n        bytes32 outcomeHash;\n    }\n\n    enum ChannelMode {Open, Challenge, Finalized}\n\n    /**\n     * @notice Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @dev Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param isFinalCount Describes how many of the submitted states have the `isFinal` property set to `true`. It is implied that the rightmost `isFinalCount` states are final, and the rest are not final.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param challengerSig The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\n     */\n    function challenge(\n        FixedPart memory fixedPart,\n        uint48 largestTurnNum,\n        ForceMoveApp.VariablePart[] memory variableParts,\n        uint8 isFinalCount, // how many of the states are final\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat,\n        Signature memory challengerSig\n    ) public virtual;\n\n    /**\n     * @notice Repsonds to an ongoing challenge registered against a state channel.\n     * @dev Repsonds to an ongoing challenge registered against a state channel.\n     * @param challenger The address of the participant whom registered the challenge.\n     * @param isFinalAB An pair of booleans describing if the challenge state and/or the response state have the `isFinal` property set to `true`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variablePartAB An pair of structs, each decribing the properties of the state channel that may change with each state update (for the challenge state and for the response state).\n     * @param sig The responder's signature on the `responseStateHash`.\n     */\n    function respond(\n        address challenger,\n        bool[2] memory isFinalAB,\n        FixedPart memory fixedPart,\n        ForceMoveApp.VariablePart[2] memory variablePartAB,\n        // variablePartAB[0] = challengeVariablePart\n        // variablePartAB[1] = responseVariablePart\n        Signature memory sig\n    ) public virtual;\n\n    /**\n     * @notice Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @dev Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param isFinalCount Describes how many of the submitted states have the `isFinal` property set to `true`. It is implied that the rightmost `isFinalCount` states are final, and the rest are not final.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     */\n    function checkpoint(\n        FixedPart memory fixedPart,\n        uint48 largestTurnNum,\n        ForceMoveApp.VariablePart[] memory variableParts,\n        uint8 isFinalCount, // how many of the states are final\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat\n    ) public virtual;\n\n    /**\n     * @notice Finalizes a channel by providing a finalization proof.\n     * @dev Finalizes a channel by providing a finalization proof.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param appPartHash The keccak256 of the abi.encode of `(challengeDuration, appDefinition, appData)`. Applies to all states in the finalization proof.\n     * @param outcomeHash The keccak256 of the abi.encode of the `outcome`. Applies to all stats in the finalization proof.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     */\n    function conclude(\n        uint48 largestTurnNum,\n        FixedPart memory fixedPart,\n        bytes32 appPartHash,\n        bytes32 outcomeHash,\n        uint8 numStates,\n        uint8[] memory whoSignedWhat,\n        Signature[] memory sigs\n    ) public virtual;\n\n    // events\n\n    /**\n     * @dev Indicates that a challenge has been registered against `channelId`.\n     * @param channelId Unique identifier for a state channel.\n     * @param turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     * @param finalizesAt The unix timestamp when `channelId` will finalize.\n     * @param challenger The address of the participant whom registered the challenge.\n     * @param isFinal Boolean denoting whether the challenge state is final.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param sigs A list of Signatures that supported the challenge\n     * @param whoSignedWhat Indexing information to identify which signature was by which participant\n     */\n    event ChallengeRegistered(\n        bytes32 indexed channelId,\n        // everything needed to respond or checkpoint\n        uint48 turnNumRecord,\n        uint48 finalizesAt,\n        address challenger,\n        bool isFinal,\n        FixedPart fixedPart,\n        ForceMoveApp.VariablePart[] variableParts,\n        Signature[] sigs,\n        uint8[] whoSignedWhat\n    );\n\n    /**\n     * @dev Indicates that a challenge, previously registered against `channelId`, has been cleared.\n     * @param channelId Unique identifier for a state channel.\n     * @param newTurnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     */\n    event ChallengeCleared(bytes32 indexed channelId, uint48 newTurnNumRecord);\n\n    /**\n     * @dev Indicates that a challenge has been registered against `channelId`.\n     * @param channelId Unique identifier for a state channel.\n     */\n    event Concluded(bytes32 indexed channelId);\n}\n"
    },
    "contracts/interfaces/ForceMoveApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev The ForceMoveApp interface calls for its children to implement an application-specific validTransition function, defining the state machine of a ForceMove state channel DApp.\n */\ninterface ForceMoveApp {\n    struct VariablePart {\n        bytes outcome;\n        bytes appData;\n    }\n\n    /**\n     * @notice Encodes application-specific rules for a particular ForceMove-compliant state channel.\n     * @dev Encodes application-specific rules for a particular ForceMove-compliant state channel.\n     * @param a State being transitioned from.\n     * @param b State being transitioned to.\n     * @param turnNumB Turn number being transitioned to.\n     * @param nParticipants Number of participants in this state channel.\n     * @return true if the transition conforms to this application's rules, false otherwise\n     */\n    function validTransition(\n        VariablePart calldata a,\n        VariablePart calldata b,\n        uint48 turnNumB,\n        uint256 nParticipants\n    ) external pure returns (bool);\n}\n"
    },
    "contracts/test/TESTNitroAdjudicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport '../NitroAdjudicator.sol';\n\n/**\n * @dev This contract extends the NitroAdjudicator contract to enable it to be more easily unit-tested. It exposes public or external functions that set storage variables or wrap otherwise internal functions. It should not be deployed in a production environment.\n */\ncontract TESTNitroAdjudicator is NitroAdjudicator {\n    // Public wrappers for internal methods:\n\n    /**\n     * @dev Wrapper for otherwise internal function. Tests whether a given address is in a given array of addresses.\n     * @param suspect A single address of interest.\n     * @param addresses A line-up of possible perpetrators.\n     * @return true if the address is in the array, false otherwise\n     */\n    function isAddressInArray(address suspect, address[] memory addresses)\n        public\n        pure\n        returns (bool)\n    {\n        return _isAddressInArray(suspect, addresses);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param participants A list of addresses representing the participants of a channel.\n     * @param stateHashes Array of keccak256(State) submitted in support of a state,\n     * @param sigs Array of Signatures, one for each participant\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @return true if the signatures are valid, false otherwise\n     */\n    function validSignatures(\n        uint48 largestTurnNum,\n        address[] memory participants,\n        bytes32[] memory stateHashes,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat // whoSignedWhat[i] is the index of the state in stateHashes that was signed by participants[i]\n    ) public pure returns (bool) {\n        return _validSignatures(largestTurnNum, participants, stateHashes, sigs, whoSignedWhat);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @param largestTurnNum Largest turnNum of the support proof\n     * @param nParticipants Number of participants in the channel\n     * @param nStates Number of states in the support proof\n     * @return true if whoSignedWhat is acceptable, false otherwise\n     */\n    function acceptableWhoSignedWhat(\n        uint8[] memory whoSignedWhat,\n        uint48 largestTurnNum,\n        uint256 nParticipants,\n        uint256 nStates\n    ) public pure returns (bool) {\n        return _acceptableWhoSignedWhat(whoSignedWhat, largestTurnNum, nParticipants, nStates);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Given a digest and digital signature, recover the signer\n     * @param _d message digest\n     * @param sig ethereum digital signature\n     * @return signer\n     */\n    function recoverSigner(bytes32 _d, Signature memory sig) public pure returns (address) {\n        return _recoverSigner(_d, sig);\n    }\n\n    /**\n     * @dev Manually set the channelStorageHashes for a given channelId.  Shortcuts the public methods (ONLY USE IN A TESTING ENVIRONMENT).\n     * @param channelId Unique identifier for a state channel.\n     * @param channelData The channelData to be hashed and stored against the channelId\n     */\n    function setChannelStorage(bytes32 channelId, ChannelData memory channelData) public {\n        channelStorageHashes[channelId] = _hashChannelData(channelData);\n    }\n\n    /**\n     * @dev Manually set the channelStorageHash for a given channelId.  Shortcuts the public methods (ONLY USE IN A TESTING ENVIRONMENT).\n     * @param channelId Unique identifier for a state channel.\n     * @param h The channelStorageHash to store against the channelId\n     */\n    function setChannelStorageHash(bytes32 channelId, bytes32 h) public {\n        channelStorageHashes[channelId] = h;\n    }\n}\n"
    },
    "contracts/examples/SingleAssetPayments.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport '../interfaces/ForceMoveApp.sol';\nimport '../Outcome.sol';\n\n/**\n * @dev The SingleAssetPayments contract complies with the ForceMoveApp interface and implements a simple payment channel with a single asset type only.\n */\ncontract SingleAssetPayments is ForceMoveApp {\n    /**\n     * @notice Encodes the payment channel update rules.\n     * @dev Encodes the payment channel update rules.\n     * @param a State being transitioned from.\n     * @param b State being transitioned to.\n     * @param turnNumB Turn number being transitioned to.\n     * @param nParticipants Number of participants in this state channel.\n     * @return true if the transition conforms to the rules, false otherwise.\n     */\n    function validTransition(\n        VariablePart memory a,\n        VariablePart memory b,\n        uint48 turnNumB,\n        uint256 nParticipants\n    ) public override pure returns (bool) {\n        Outcome.OutcomeItem[] memory outcomeA = abi.decode(a.outcome, (Outcome.OutcomeItem[]));\n        Outcome.OutcomeItem[] memory outcomeB = abi.decode(b.outcome, (Outcome.OutcomeItem[]));\n\n        // Throws if more than one asset\n        require(outcomeA.length == 1, 'SingleAssetPayments: outcomeA: Only one asset allowed');\n        require(outcomeB.length == 1, 'SingleAssetPayments: outcomeB: Only one asset allowed');\n\n        // Throws unless the assetoutcome is an allocation\n        Outcome.AssetOutcome memory assetOutcomeA = abi.decode(\n            outcomeA[0].assetOutcomeBytes,\n            (Outcome.AssetOutcome)\n        );\n        Outcome.AssetOutcome memory assetOutcomeB = abi.decode(\n            outcomeB[0].assetOutcomeBytes,\n            (Outcome.AssetOutcome)\n        );\n        require(\n            assetOutcomeA.assetOutcomeType == uint8(Outcome.AssetOutcomeType.Allocation),\n            'SingleAssetPayments: outcomeA: AssetOutcomeType must be Allocation'\n        );\n        require(\n            assetOutcomeB.assetOutcomeType == uint8(Outcome.AssetOutcomeType.Allocation),\n            'SingleAssetPayments: outcomeB: AssetOutcomeType must be Allocation'\n        );\n\n        // Throws unless that allocation has exactly n outcomes\n        Outcome.AllocationItem[] memory allocationA = abi.decode(\n            assetOutcomeA.allocationOrGuaranteeBytes,\n            (Outcome.AllocationItem[])\n        );\n        Outcome.AllocationItem[] memory allocationB = abi.decode(\n            assetOutcomeB.allocationOrGuaranteeBytes,\n            (Outcome.AllocationItem[])\n        );\n        require(\n            allocationA.length == nParticipants,\n            'SingleAssetPayments: outcomeA: Allocation length must equal number of participants'\n        );\n        require(\n            allocationB.length == nParticipants,\n            'SingleAssetPayments: outcomeB: Allocation length must equal number of participants'\n        );\n\n        // Interprets the nth outcome as benefiting participant n\n        // checks the destinations have not changed\n        // Checks that the sum of assets hasn't changed\n        // And that for all non-movers\n        // the balance hasn't decreased\n        uint256 allocationSumA;\n        uint256 allocationSumB;\n        for (uint256 i = 0; i < nParticipants; i++) {\n            require(\n                allocationB[i].destination == allocationA[i].destination,\n                'SingleAssetPayments: Destinations may not change'\n            );\n            allocationSumA += allocationA[i].amount;\n            allocationSumB += allocationB[i].amount;\n            if (i != turnNumB % nParticipants) {\n                require(\n                    allocationB[i].amount >= allocationA[i].amount,\n                    'SingleAssetPayments: Nonmovers cannot have their balance decreased'\n                );\n            }\n        }\n        require(\n            allocationSumA == allocationSumB,\n            'SingleAssetPayments: Total amount allocated cannot change'\n        );\n\n        return true;\n    }\n}\n"
    },
    "contracts/TrivialApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/ForceMoveApp.sol';\n\n/**\n * @dev The Trivialp contracts complies with the ForceMoveApp interface and allows all transitions, regardless of the data. Used for testing purposes.\n */\ncontract TrivialApp is ForceMoveApp {\n    /**\n     * @notice Encodes trivial rules.\n     * @dev Encodes trivial rules.\n     * @return true.\n     */\n    function validTransition(\n        VariablePart memory, // a\n        VariablePart memory, // b\n        uint48, // turnNumB\n        uint256 // nParticipants\n    ) public override pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/test/TESTForceMove.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport '../ForceMove.sol';\n\n/**\n * @dev This contract extends the ForceMove contract to enable it to be more easily unit-tested. It exposes public or external functions that set storage variables or wrap otherwise internal functions. It should not be deployed in a production environment.\n */\ncontract TESTForceMove is ForceMove {\n    // Public wrappers for internal methods:\n\n    /**\n     * @dev Wrapper for otherwise internal function. Tests whether a given address is in a given array of addresses.\n     * @param suspect A single address of interest.\n     * @param addresses A line-up of possible perpetrators.\n     * @return true if the address is in the array, false otherwise\n     */\n    function isAddressInArray(address suspect, address[] memory addresses)\n        public\n        pure\n        returns (bool)\n    {\n        return _isAddressInArray(suspect, addresses);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param participants A list of addresses representing the participants of a channel.\n     * @param stateHashes Array of keccak256(State) submitted in support of a state,\n     * @param sigs Array of Signatures, one for each participant\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @return true if the signatures are valid, false otherwise\n     */\n    function validSignatures(\n        uint48 largestTurnNum,\n        address[] memory participants,\n        bytes32[] memory stateHashes,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat // whoSignedWhat[i] is the index of the state in stateHashes that was signed by participants[i]\n    ) public pure returns (bool) {\n        return _validSignatures(largestTurnNum, participants, stateHashes, sigs, whoSignedWhat);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @param largestTurnNum Largest turnNum of the support proof\n     * @param nParticipants Number of participants in the channel\n     * @param nStates Number of states in the support proof\n     * @return true if whoSignedWhat is acceptable, false otherwise\n     */\n    function acceptableWhoSignedWhat(\n        uint8[] memory whoSignedWhat,\n        uint48 largestTurnNum,\n        uint256 nParticipants,\n        uint256 nStates\n    ) public pure returns (bool) {\n        return _acceptableWhoSignedWhat(whoSignedWhat, largestTurnNum, nParticipants, nStates);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Given a digest and digital signature, recover the signer\n     * @param _d message digest\n     * @param sig ethereum digital signature\n     * @return signer\n     */\n    function recoverSigner(bytes32 _d, Signature memory sig) public pure returns (address) {\n        return _recoverSigner(_d, sig);\n    }\n\n    // public setter for channelStorageHashes\n\n    /**\n     * @dev Manually set the channelStorageHash for a given channelId.  Shortcuts the public methods (ONLY USE IN A TESTING ENVIRONMENT).\n     * @param channelId Unique identifier for a state channel.\n     * @param channelData The channelData to be hashed and stored against the channelId\n     */\n    function setChannelStorage(bytes32 channelId, ChannelData memory channelData) public {\n        if (channelData.finalizesAt == 0) {\n            require(\n                channelData.stateHash == bytes32(0) &&\n                    channelData.challengerAddress == address(0) &&\n                    channelData.outcomeHash == bytes32(0),\n                'Invalid open channel'\n            );\n        }\n\n        channelStorageHashes[channelId] = hashChannelData(channelData);\n    }\n\n    /**\n     * @dev Manually set the channelStorageHash for a given channelId.  Shortcuts the public methods (ONLY USE IN A TESTING ENVIRONMENT).\n     * @param channelId Unique identifier for a state channel.\n     * @param h The channelStorageHash to store against the channelId\n     */\n    function setChannelStorageHash(bytes32 channelId, bytes32 h) public {\n        channelStorageHashes[channelId] = h;\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Hashes the input data and formats it for on chain storage.\n     * @param channelData ChannelData data.\n     */\n    function hashChannelData(ChannelData memory channelData) public pure returns (bytes32 newHash) {\n        return _hashChannelData(channelData);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Checks that a given ChannelData struct matches a supplied bytes32 when formatted for storage.\n     * @param cs A given ChannelData data structure.\n     * @param h Some data in on-chain storage format.\n     */\n    function matchesHash(ChannelData memory cs, bytes32 h) public pure returns (bool) {\n        return _matchesHash(cs, h);\n    }\n\n    /**\n     * @dev Wrapper for otherwise internal function. Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function requireChannelOpen(bytes32 channelId) public view {\n        _requireChannelOpen(channelId);\n    }\n}\n"
    },
    "contracts/CountingApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/ForceMoveApp.sol';\n\n/**\n * @dev The CountingApp contracts complies with the ForceMoveApp interface and allows only for a simple counter to be incremented. Used for testing purposes.\n */\ncontract CountingApp is ForceMoveApp {\n    struct CountingAppData {\n        uint256 counter;\n    }\n\n    /**\n     * @notice Decodes the appData.\n     * @dev Decodes the appData.\n     * @param appDataBytes The abi.encode of a CountingAppData struct describing the application-specific data.\n     * @return A CountingAppDatat struct containing the application-specific data.\n     */\n    function appData(bytes memory appDataBytes) internal pure returns (CountingAppData memory) {\n        return abi.decode(appDataBytes, (CountingAppData));\n    }\n\n    /**\n     * @notice Encodes the CountingApp rules.\n     * @dev Encodes the CountingApp rules.\n     * @param a State being transitioned from.\n     * @param b State being transitioned to.\n     * @return true if the transition conforms to the rules, false otherwise.\n     */\n    function validTransition(\n        VariablePart memory a,\n        VariablePart memory b,\n        uint48, // turnNumB, unused\n        uint256 // nParticipants, unused\n    ) public override pure returns (bool) {\n        require(\n            appData(b.appData).counter == appData(a.appData).counter + 1,\n            'CountingApp: Counter must be incremented'\n        );\n        require(\n            keccak256(b.outcome) == keccak256(a.outcome),\n            'CountingApp: Outcome must not change'\n        );\n        return true;\n    }\n}\n"
    },
    "contracts/ETHAssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport './AssetHolder.sol';\n\n/**\n * @dev Ther ETHAssetHolder contract extends the AssetHolder contract, and adds the following functionality: it allows ETH to be escrowed against a state channelId and to be transferred to external destinations.\n */\ncontract ETHAssetHolder is AssetHolder {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Constructor function storing the AdjudicatorAddress.\n     * @dev Constructor function storing the AdjudicatorAddress.\n     * @param _AdjudicatorAddress Address of an Adjudicator  contract, supplied at deploy-time.\n     */\n    constructor(address _AdjudicatorAddress) public {\n        AdjudicatorAddress = _AdjudicatorAddress;\n    }\n\n    /**\n     * @notice Deposit ETH against a given destination.\n     * @dev Deposit ETH against a given destination.\n     * @param destination ChannelId to be credited.\n     * @param expectedHeld The number of wei the depositor believes are _already_ escrowed against the channelId.\n     * @param amount The intended number of wei to be deposited.\n     */\n    function deposit(\n        bytes32 destination,\n        uint256 expectedHeld,\n        uint256 amount\n    ) public payable {\n        require(!_isExternalDestination(destination), 'Cannot deposit to external destination');\n        require(msg.value == amount, 'Insufficient ETH for ETH deposit');\n        uint256 amountDeposited;\n        // this allows participants to reduce the wait between deposits, while protecting them from losing funds by depositing too early. Specifically it protects against the scenario:\n        // 1. Participant A deposits\n        // 2. Participant B sees A's deposit, which means it is now safe for them to deposit\n        // 3. Participant B submits their deposit\n        // 4. The chain re-orgs, leaving B's deposit in the chain but not A's\n        require(\n            holdings[destination] >= expectedHeld,\n            'Deposit | holdings[destination] is less than expected'\n        );\n        require(\n            holdings[destination] < expectedHeld.add(amount),\n            'Deposit | holdings[destination] already meets or exceeds expectedHeld + amount'\n        );\n\n        // The depositor wishes to increase the holdings against channelId to amount + expectedHeld\n        // The depositor need only deposit (at most) amount + (expectedHeld - holdings) (the term in parentheses is non-positive)\n\n        amountDeposited = expectedHeld.add(amount).sub(holdings[destination]); // strictly positive\n        // require successful deposit before updating holdings (protect against reentrancy)\n\n        holdings[destination] = holdings[destination].add(amountDeposited);\n        emit Deposited(destination, amountDeposited, holdings[destination]);\n\n        // refund whatever wasn't deposited.\n        uint256 refund = amount.sub(amountDeposited);\n        (bool success, ) = msg.sender.call{value: refund}('');\n        require(success, 'Could not refund excess funds');\n    }\n\n    /**\n     * @notice Transfers the given number of wei to a supplied ethereum address.\n     * @dev Transfers the given number of wei to a supplied ethereum address.\n     * @param destination Ethereum address to be credited.\n     * @param amount Quantity of wei to be transferred.\n     */\n    function _transferAsset(address payable destination, uint256 amount) internal override {\n        (bool success, ) = destination.call{value: amount}('');\n        require(success, 'Could not transfer asset');\n    }\n}\n"
    },
    "contracts/test/TestEthAssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport '../ETHAssetHolder.sol';\n\n/**\n * @dev This contract is a clone of the ETHAssetHolder contract. It will be initialized to point to the TestNitroAdjudicator.\n */\ncontract TestEthAssetHolder is ETHAssetHolder {\n    constructor(address _AdjudicatorAddress) public ETHAssetHolder(_AdjudicatorAddress) {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}